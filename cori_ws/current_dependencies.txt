=== ./kill_all.bash ===
#!/bin/bash
echo "🧹 CORI System Cleanup"
echo "====================="

echo "Killing all ROS and Gazebo processes..."

# Kill all ROS processes
pkill -f "ros2" 2>/dev/null || true
pkill -f "ign gazebo" 2>/dev/null || true
pkill -f "gz sim" 2>/dev/null || true
pkill -f "v4l2_camera" 2>/dev/null || true
pkill -f "robot_state_publisher" 2>/dev/null || true
pkill -f "cori_cv" 2>/dev/null || true
pkill -f "laundry_color_detector" 2>/dev/null || true
pkill -f "simple_color_detector" 2>/dev/null || true
pkill -f "color_display" 2>/dev/null || true

# Force kill any stubborn processes
pkill -9 -f "v4l2" 2>/dev/null || true
pkill -9 -f "camera" 2>/dev/null || true

# Wait for processes to die
sleep 3

# Reset USB camera driver (simulates unplug/replug)
echo "🔄 Resetting USB camera driver..."
sudo modprobe -r uvcvideo 2>/dev/null || true
sleep 2
sudo modprobe uvcvideo 2>/dev/null || true
sleep 2

echo "✅ Cleanup complete!"
echo "📷 Camera devices available: $(ls /dev/video* 2>/dev/null | tr '\n' ' ')"
echo "💡 System ready for restart"
echo ""
echo "🎯 To restart CORI system, run: ./build.bash"
=== ./src/cori_cv/cori_cv/cori_simulator.py ===
#!/usr/bin/env python3
"""
CORI Laundry Sorting Assistant
Intelligent laundry sorting with learning capabilities and personality
"""

import json
import time
import random
import datetime
import os
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

@dataclass
class DetectedItem:
    color: str
    confidence: float
    timestamp: float

class CORILaundryAssistant:
    def __init__(self, database_file: str = "../../cori_spatial_database.json"):
        self.database_file = database_file
        self.database = self.load_database()
        self.initialize_laundry_system()
        
    def initialize_laundry_system(self):
        """Initialize laundry-specific database structure"""
        if "laundry_data" not in self.database:
            self.database["laundry_data"] = {
                "total_items_sorted": 0,
                "hamper_counts": {"Lights": 0, "Darks": 0, "Colors": 0},
                "learning_database": {},  # color -> category mappings
                "user_corrections": [],
                "confidence_level": "learning",  # learning -> tentative -> confident
                "custom_colors": {},  # user-defined colors
                "sorted_items_history": []  # track what went where
            }
            self.save_database()
    
    def load_database(self) -> Dict:
        """Load the CORI spatial database"""
        try:
            with open(self.database_file, 'r') as f:
                database = json.load(f)
                # Ensure laundry_data exists with all required keys
                if "laundry_data" not in database or not isinstance(database["laundry_data"], dict):
                    database["laundry_data"] = {
                        "total_items_sorted": 0,
                        "hamper_counts": {"Lights": 0, "Darks": 0, "Colors": 0},
                        "learning_database": {},
                        "user_corrections": [],
                        "confidence_level": "learning",
                        "custom_colors": {},
                        "sorted_items_history": []
                    }
                return database
        except FileNotFoundError:
            print(f"Creating new database file: {self.database_file}")
            return {
                "metadata": {
                    "created": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "description": "CORI Spatial Object Database",
                    "version": "3.0"
                },
                "objects": {},
                "laundry_data": {
                    "total_items_sorted": 0,
                    "hamper_counts": {"Lights": 0, "Darks": 0, "Colors": 0},
                    "learning_database": {},
                    "user_corrections": [],
                    "confidence_level": "learning",
                    "custom_colors": {},
                    "sorted_items_history": []
                }
            }
    
    def save_database(self):
        """Save the database back to file"""
        try:
            with open(self.database_file, 'w') as f:
                json.dump(self.database, f, indent=2)
        except Exception as e:
            print(f"Warning: Could not save database: {e}")
    
    def get_learning_phase(self) -> str:
        """Determine CORI's current learning phase"""
        total_sorted = self.database["laundry_data"]["total_items_sorted"]
        
        if total_sorted < 15:
            return "learning"
        elif total_sorted < 30:
            return "tentative"
        else:
            return "confident"
    
    def show_startup_sequence(self):
        """Show cool CORI startup sequence with improved ASCII art"""
        print("\n" * 2)
        
        # Animated startup effect
        print("🤖 Initializing C.O.R.I. system", end="")
        for i in range(4):
            time.sleep(0.4)
            print(".", end="", flush=True)
        print("\n")
        time.sleep(0.3)
        
        # Improved C.O.R.I. ASCII art with better formatting
        print("╔" + "═" * 68 + "╗")
        print("║" + " " * 68 + "║")
        print("║" + "   ██████╗    ██████╗    ██████╗    ██╗".center(68) + "║")
        print("║" + "  ██╔════╝   ██╔═══██╗   ██╔══██╗   ██║".center(68) + "║")
        print("║" + "  ██║        ██║   ██║   ██████╔╝   ██║".center(68) + "║")
        print("║" + "  ██║        ██║   ██║   ██╔══██╗   ██║".center(68) + "║")
        print("║" + "  ╚██████╗██╗╚██████╔╝██╗██║  ██║██╗██║".center(68) + "║")
        print("║" + "   ╚═════╝╚═╝ ╚═════╝ ╚═╝╚═╝  ╚═╝╚═╝╚═╝".center(68) + "║")
        print("║" + " " * 68 + "║")
        print("║" + "    Cooperative Organizational Robotic Intelligence".center(68) + "║")
        print("║" + "                 Laundry Sorting Assistant".center(68) + "║")
        print("║" + " " * 68 + "║")
        
        # Ensure laundry_data exists before accessing
        if "laundry_data" not in self.database or not isinstance(self.database["laundry_data"], dict):
            self.initialize_laundry_system()
        
        # Show current status
        learning_phase = self.get_learning_phase()
        total_sorted = self.database["laundry_data"]["total_items_sorted"]
        
        status_line = f"Status: {learning_phase.title()} Mode | Items Sorted: {total_sorted}"
        print("║" + status_line.center(68) + "║")
        print("║" + " " * 68 + "║")
        print("╚" + "═" * 68 + "╝")
        
        # Add some personality based on learning phase
        if learning_phase == "learning":
            print("\n🎓 I'm still learning! Please help me by correcting any mistakes.")
        elif learning_phase == "tentative":
            print("\n🤔 I'm getting more confident, but I might still need guidance.")
        else:
            print("\n💪 I'm feeling confident about my sorting abilities!")
        
        print("\n" + "─" * 50)
        print("Ready to sort your laundry! 🧺✨")
        print("─" * 50 + "\n")
        
        time.sleep(0.5)
        
        # Check if there's existing data
        if total_sorted > 0:
            items_text = "item" if total_sorted == 1 else "items"
            counts = self.database["laundry_data"]["hamper_counts"]
            print(f"I found existing data! You've already sorted {total_sorted} {items_text}.")
            print(f"Current hampers: Lights({counts['Lights']}) | Darks({counts['Darks']}) | Colors({counts['Colors']})")
            
            print("\nWhat would you like to do?")
            print("   1) 🔄 Continue where we left off")
            print("   2) 👀 Check what's in the hampers")
            print("   3) 🆕 Start fresh (archive current data)")
            print("   4) 🚪 Exit C.O.R.I.")
            
            while True:
                choice = input(f"\n> What's it gonna be? (1-4): ").strip()
                
                if choice in ['1', 'continue', 'sort']:
                    print("\n🚀 Awesome! Let's continue sorting your laundry!")
                    return self.detect_clothing_item()
                elif choice in ['2', 'check', 'hampers']:
                    self.show_all_hamper_contents()
                    input("\nPress enter to continue...")
                    return self.show_startup_sequence()
                elif choice in ['3', 'fresh', 'new']:
                    success = self.create_blank_database()
                    if success:
                        print("\n🎉 Fresh start activated! Let's begin sorting!")
                        return self.detect_clothing_item()
                    else:
                        return self.show_startup_sequence()
                elif choice in ['4', 'quit', 'exit']:
                    return None
                else:
                    print("❌ Please choose 1, 2, 3, or 4 (or say 'continue', 'check', 'fresh', 'quit')")
        else:
            print("Looks like this is your first time! Welcome aboard! 🎉")
            print("\nWhat would you like to do?")
            print("   1) 🆕 Start sorting laundry!")
            print("   2) 📖 Learn more about how C.O.R.I. works")
            print("   3) 🚪 Exit for now")
            
            while True:
                choice = input(f"\n> Ready to dive in? (1-3): ").strip()
                
                if choice in ['1', 'start', 'sort']:
                    print("\n🎉 Perfect! Let's create your laundry sorting profile!")
                    print("I'll learn your preferences as we go. This is going to be fun!")
                    return self.detect_clothing_item()
                elif choice in ['2', 'learn', 'help']:
                    self.show_cori_explanation()
                    return self.show_startup_sequence()
                elif choice in ['3', 'quit', 'exit']:
                    print("\n👋 No problem! Come back anytime!")
                    return None
                else:
                    print("❌ Please choose 1, 2, or 3 (or say 'start', 'learn', 'quit')")
    
    def show_cori_explanation(self):
        """Explain how CORI works in detail"""
        print(f"\n📖 HOW C.O.R.I. WORKS:")
        print(f"=" * 50)
        print(f"\n🎯 THREE LEARNING PHASES:")
        print(f"   Phase 1 (Items 1-15): I ask you about everything")
        print(f"   Phase 2 (Items 16-30): I make suggestions, you approve")
        print(f"   Phase 3 (Items 31+): I sort confidently, you can override")
        
        print(f"\n🗂️  THREE HAMPER CATEGORIES:")
        print(f"   🤍 LIGHTS: Whites, creams, light colors")
        print(f"   ⚫ DARKS: Blacks, navy, dark colors that might bleed")
        print(f"   🌈 COLORS: Bright colors, medium tones")
        
        print(f"\n🧠 SMART FEATURES:")
        print(f"   • I remember your preferences for each color")
        print(f"   • I learn new colors you teach me")
        print(f"   • I adapt to YOUR specific sorting style")
        print(f"   • I get better every time we work together")
        
        input(f"\nPress enter to continue...")
    
    def create_blank_database(self):
        """Create a completely fresh database with user choice for old data"""
        # Check if current database has data
        if self.database["laundry_data"]["total_items_sorted"] > 0:
            print(f"\n📋 You currently have {self.database['laundry_data']['total_items_sorted']} items sorted.")
            print("What would you like to do with this data?")
            print("   1) Save it with a custom name for later")
            print("   2) Auto-archive with timestamp") 
            print("   3) Delete it (permanent)")
            print("   4) Cancel (keep current data)")
            
            choice = input("\nChoose 1, 2, 3, or 4: ").strip()
            
            if choice == "1":
                # Custom name save
                custom_name = input("Enter a name for this sorting session: ").strip()
                if not custom_name:
                    custom_name = "custom_session"
                
                # Clean the name for filename
                safe_name = "".join(c for c in custom_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
                safe_name = safe_name.replace(' ', '_')
                
                archive_file = self.database_file.replace(".json", f"_{safe_name}.json")
                
                try:
                    with open(archive_file, 'w') as f:
                        json.dump(self.database, f, indent=2)
                    print(f"💾 Session saved as: {archive_file}")
                except Exception as e:
                    print(f"⚠️  Could not save session: {e}")
                    
            elif choice == "2":
                # Auto-archive with timestamp
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                archive_file = self.database_file.replace(".json", f"_archive_{timestamp}.json")
                
                try:
                    with open(archive_file, 'w') as f:
                        json.dump(self.database, f, indent=2)
                    print(f"💾 Session archived as: {archive_file}")
                except Exception as e:
                    print(f"⚠️  Could not archive session: {e}")
                    
            elif choice == "3":
                # Delete - just confirm
                confirm = input("Are you sure you want to delete this data? (y/n): ").strip().lower()
                if confirm not in ['y', 'yes']:
                    print("📋 Keeping current data. Canceling fresh start.")
                    return False
                else:
                    print("🗑️  Previous data will be deleted")
            elif choice == "4":
                print("📋 Keeping current data. Canceling fresh start.")
                return False
            else:
                print("📋 Invalid choice. Keeping current data.")
                return False
        
        # Create fresh database
        self.database = {
            "metadata": {
                "created": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "description": "CORI Spatial Object Database - Fresh Start",
                "version": "3.0"
            },
            "objects": {},
            "laundry_data": {
                "total_items_sorted": 0,
                "hamper_counts": {"Lights": 0, "Darks": 0, "Colors": 0},
                "learning_database": {},
                "user_corrections": [],
                "confidence_level": "learning",
                "custom_colors": {},
                "sorted_items_history": []
            }
        }
        self.save_database()
        print("✅ Fresh database created! Ready to start learning your preferences.")
        return True
    
    def detect_clothing_item(self) -> Optional[DetectedItem]:
        """Simulate clothing item detection with natural conversation"""
        total_sorted = self.database["laundry_data"]["total_items_sorted"]
        
        # Natural, varied prompts based on progress
        prompts = [
            "What's next?",
            "Show me another item!",
            "What do you have for me?",
            "Ready for the next one!",
            "Let's keep going - what's this?",
            "Bring on the next piece!",
            "What are we sorting now?",
            "Show me what you've got!",
            "Another item coming up?",
            "What's this one?"
        ]
        
        # Occasional encouragement based on progress
        if total_sorted > 0 and total_sorted % 5 == 0:
            encouragements = [
                f"Nice work! We've sorted {total_sorted} items together.",
                f"You're getting the hang of this! {total_sorted} items done.",
                f"Great teamwork! {total_sorted} items sorted so far.",
                f"Look at us go! {total_sorted} items in the books."
            ]
            print(f"\n🎉 {random.choice(encouragements)}")
        
        # Simple, natural prompt
        if total_sorted == 0:
            prompt = "What's the first item?"
        else:
            prompt = random.choice(prompts)
            
        print(f"\n{prompt}")
        print("(Examples: 'red shirt', 'blue jeans' | Type 'help', 'stats', 'menu', or 'quit')")
        
        item_input = input("> ").strip().lower()
        
        if item_input in ['quit', 'exit']:
            return None
        elif item_input == 'menu':
            return self.show_main_menu()
        elif item_input in ['help', '?']:
            print("\n💡 Just tell me what you see! Like 'red shirt' or 'blue jeans'")
            print("   Type 'menu' for options, 'quit' to exit, 'stats' for progress")
            return self.detect_clothing_item()
        elif item_input == 'stats':
            self.show_quick_stats()
            return self.detect_clothing_item()
        
        return self.process_item_input(item_input)
    
    def show_quick_stats(self):
        """Show quick stats without the full menu"""
        counts = self.database["laundry_data"]["hamper_counts"]
        total = self.database["laundry_data"]["total_items_sorted"]
        phase = self.get_learning_phase()
        
        items_text = "item" if total == 1 else "items"
        print(f"\n📊 Quick stats: {total} {items_text} sorted")
        print(f"   Lights: {counts['Lights']} | Darks: {counts['Darks']} | Colors({counts['Colors']})")
        
        if phase == "learning":
            remaining = 15 - total
            print(f"   I'm still learning! {remaining} more until I get confident.")
        elif phase == "tentative":
            remaining = 30 - total  
            print(f"   Getting smarter! {remaining} more until I'm an expert.")
        else:
            print(f"   I'm a laundry sorting expert now! 🎓")
    
    def show_main_menu(self) -> Optional[DetectedItem]:
        """Show the main menu when explicitly requested"""
        total_sorted = self.database["laundry_data"]["total_items_sorted"]
        counts = self.database["laundry_data"]["hamper_counts"]
        
        items_text = "item" if total_sorted == 1 else "items"
        
        print(f"\n🤖 Hey! I've sorted {total_sorted} {items_text} and I'm getting better at understanding your preferences.")
        print(f"\nCurrent hampers:  Lights({counts['Lights']}) | Darks({counts['Darks']}) | Colors({counts['Colors']})")
        
        # Show custom colors if any
        if "custom_colors" in self.database["laundry_data"] and self.database["laundry_data"]["custom_colors"]:
            custom_colors = list(self.database["laundry_data"]["custom_colors"].keys())
            print(f"Custom colors I know: {', '.join(custom_colors)}")
        
        print("\nWhat would you like to do?")
        print("   1) Continue sorting items")
        print("   2) Check hamper contents ('lights', 'darks', 'colors', or 'all')")
        print("   3) Start fresh training session")
        print("   4) Quit")
        
        user_input = input("\n> ").strip().lower()
        
        if user_input in ['1', 'continue', 'sort', '']:
            return self.detect_clothing_item()
        elif user_input in ['3', 'new', 'reset', 'fresh', 'start over']:
            success = self.create_blank_database()
            if success:
                return self.detect_clothing_item()
            else:
                return self.show_main_menu()
        elif user_input in ['4', 'quit', 'exit']:
            return None
        elif user_input in ['2', 'lights', 'darks', 'colors', 'all']:
            if user_input in ['lights', 'darks', 'colors']:
                self.show_hamper_contents(user_input.title())
            else:
                self.show_all_hamper_contents()
            input("\nPress enter to continue...")
            return self.show_main_menu()
        else:
            # They might be entering an item directly
            return self.process_item_input(user_input)
    
    def process_item_input(self, item_input: str) -> Optional[DetectedItem]:
        """Process the item input from user with natural responses"""
        # Parse the combined color + clothing input
        color_input, clothing_type = self.parse_item_input(item_input)
        
        if not color_input:
            responses = [
                "Hmm, I didn't catch that. Try 'red shirt' or 'blue pants'",
                "Could you be more specific? Like 'green sweater'?",
                "I need a color and item type - like 'white socks'",
                "What color is it? And what kind of clothing?"
            ]
            print(f"🤔 {random.choice(responses)}")
            return self.detect_clothing_item()
        
        # Normalize color input and handle common variations/misspellings
        color_input = self.normalize_color_input(color_input)
        
        # Get current known colors from database
        known_colors = self.get_known_colors()
        
        if color_input not in known_colors:
            # New color detected - ask user to define it naturally
            new_color_category = self.define_new_color(color_input)
            if not new_color_category:
                return self.detect_clothing_item()  # User cancelled, try again
        
        # More natural detection responses
        detection_responses = [
            f"Ah, a {color_input} {clothing_type}!",
            f"I see a {color_input} {clothing_type}.",
            f"Got it - {color_input} {clothing_type}!",
            f"Nice, a {color_input} {clothing_type}.",
            f"Okay, {color_input} {clothing_type} coming up!"
        ]
        
        print(f"👀 {random.choice(detection_responses)}")
        
        # Brief pause for more natural feel
        time.sleep(0.5)
        
        return DetectedItem(
            color=f"{color_input}#{clothing_type}",
            confidence=random.uniform(0.85, 0.98),
            timestamp=time.time()
        )
    
    def parse_item_input(self, item_input: str) -> Tuple[Optional[str], str]:
        """Parse combined color + clothing input like 'green pants' or 'white shirt'"""
        if not item_input or item_input == 'quit':
            return None, ""
        
        # Common clothing types to look for
        clothing_types = [
            'shirt', 'shirts', 'pants', 'jeans', 'shorts', 'sock', 'socks', 
            'dress', 'skirt', 'jacket', 'coat', 'sweater', 'hoodie', 'top',
            'blouse', 'tank', 'tee', 't-shirt', 'polo', 'cardigan', 'vest',
            'underwear', 'bra', 'boxers', 'briefs', 'pajamas', 'pjs', 'sleepwear',
            'towel', 'sheets', 'pillowcase', 'blanket'
        ]
        
        words = item_input.split()
        
        # Look for clothing type in the input
        clothing_type = "item"  # default
        color_words = []
        
        for word in words:
            if word in clothing_types:
                clothing_type = word
            else:
                color_words.append(word)
        
        # Reconstruct color from remaining words
        color_input = " ".join(color_words).strip()
        
        # Handle common patterns
        if not color_input and len(words) >= 2:
            # Try assuming first word is color, rest is clothing type
            color_input = words[0]
            clothing_type = " ".join(words[1:])
        elif not color_input:
            # Single word input - assume it's a color
            color_input = item_input
            clothing_type = "item"
        
        return color_input if color_input else None, clothing_type
    
    def normalize_color_input(self, color_input: str) -> str:
        """Normalize color input and handle common variations/misspellings"""
        # Handle common misspellings and variations
        color_corrections = {
            # Grey/Gray variations
            'light_grey': 'light grey', 'light_gray': 'light grey', 'lightgrey': 'light grey', 'lightgray': 'light grey',
            'dark_grey': 'dark grey', 'dark_gray': 'dark grey', 'darkgrey': 'dark grey', 'darkgray': 'dark grey',
            
            # Pink variations
            'light_pink': 'light pink', 'lightpink': 'light pink',
            'bright_pink': 'bright pink', 'brightpink': 'bright pink',
            
            # Blue variations
            'dark_blue': 'dark blue', 'darkblue': 'dark blue',
            'bright_blue': 'bright blue', 'brightblue': 'bright blue',
            
            # Green variations
            'dark_green': 'dark green', 'darkgreen': 'dark green',
            'bright_green': 'bright green', 'brightgreen': 'bright green',
            
            # Common misspellings
            'yelow': 'yellow', 'yelllow': 'yellow', 'purpel': 'purple', 'purpal': 'purple',
            'ornage': 'orange', 'oragne': 'orange', 'creme': 'cream', 'navey': 'navy', 'nafy': 'navy'
        }
        
        return color_corrections.get(color_input, color_input)
    
    def get_known_colors(self) -> List[str]:
        """Get all known colors from database and defaults"""
        # Default colors
        default_colors = [
            'white', 'light grey', 'tan', 'yellow', 'cream', 'light pink',
            'red', 'blue', 'green', 'orange', 'purple', 'bright pink', 
            'black', 'dark grey', 'navy', 'dark blue', 'brown', 'dark green'
        ]
        
        # Add any custom colors from database
        if "custom_colors" in self.database["laundry_data"]:
            custom_colors = list(self.database["laundry_data"]["custom_colors"].keys())
            default_colors.extend(custom_colors)
        
        return default_colors
    
    def define_new_color(self, color_input: str) -> Optional[str]:
        """Allow user to define a new color and its category"""
        print(f"\n🎨 I don't know the color '{color_input}' yet!")
        print("Would you like to teach me about this color?")
        
        teach = input("Teach me this color? (y/n): ").strip().lower()
        if teach not in ['y', 'yes']:
            print("No problem! Try using a color I already know.")
            return None
        
        print(f"\n🤔 Where should '{color_input}' items usually go?")
        print("1) Lights (whites, creams, light colors)")
        print("2) Darks (blacks, dark colors that might bleed)")  
        print("3) Colors (bright colors, medium tones)")
        
        while True:
            choice = input("Choose 1, 2, or 3: ").strip()
            if choice == "1":
                category = "Lights"
                break
            elif choice == "2":
                category = "Darks"
                break
            elif choice == "3":
                category = "Colors"
                break
            else:
                print("Please choose 1, 2, or 3")
        
        # Save the new color to database
        if "custom_colors" not in self.database["laundry_data"]:
            self.database["laundry_data"]["custom_colors"] = {}
        
        self.database["laundry_data"]["custom_colors"][color_input] = category
        self.save_database()
        
        print(f"✅ Great! I'll remember that '{color_input}' goes in {category}")
        return category
    
    def get_default_category(self, color: str) -> str:
        """Get default laundry category based on color"""
        lights = ['white', 'light grey', 'tan', 'yellow', 'cream', 'light pink']
        darks = ['black', 'dark grey', 'navy', 'dark blue', 'brown', 'dark green']
        colors = ['red', 'blue', 'green', 'orange', 'purple', 'bright pink']
        
        base_color = color.split('#')[0] if '#' in color else color
        
        # Check custom colors first
        if "custom_colors" in self.database["laundry_data"]:
            if base_color in self.database["laundry_data"]["custom_colors"]:
                return self.database["laundry_data"]["custom_colors"][base_color]
        
        # Check default categories
        if base_color in lights:
            return "Lights"
        elif base_color in darks:
            return "Darks"
        elif base_color in colors:
            return "Colors"
        else:
            return "Colors"  # Default fallback
    
    def get_cori_reasoning(self, color: str, suggested_category: str) -> str:
        """Generate CORI's reasoning for sorting decision"""
        base_color = color.replace('#', ' ').split(' ')[0] if '#' in color else color.replace('_', ' ')
        
        reasoning_map = {
            "Lights": {
                "white": "White items need to stay bright and clean!",
                "light grey": "Light colors should stay with other lights to avoid getting dingy",
                "tan": "Tan is delicate and light - safer with the whites",
                "yellow": "Yellow can get muddy with dark colors",
                "cream": "Cream is basically white - definitely goes with lights",
                "light pink": "Light pink is too delicate for the other loads"
            },
            "Darks": {
                "black": "Black is the darkest - definitely goes with darks",
                "dark grey": "Dark grey might leave lint on lighter items",
                "navy": "Navy is dark enough to potentially bleed color",
                "dark blue": "Dark blue should stay with other dark items",
                "brown": "Brown is a heavy, dark color",
                "dark green": "Dark green is too intense for the color load"
            },
            "Colors": {
                "red": "Red has good color but isn't dark enough to go with darks",
                "blue": "Blue is bright but not too light or too dark",
                "green": "Green is a nice middle-ground color",
                "orange": "Orange is vibrant but not bleeding-level dark",
                "purple": "Purple is colorful but not delicate like lights",
                "bright pink": "Bright pink has personality - goes with other colors"
            }
        }
        
        # Check if it's a custom color
        if "custom_colors" in self.database["laundry_data"]:
            if base_color in self.database["laundry_data"]["custom_colors"]:
                return f"You taught me that {base_color} items go in {suggested_category}"
        
        return reasoning_map.get(suggested_category, {}).get(base_color, 
                                                           f"{base_color} seems like a good fit for {suggested_category}")
    
    def make_sorting_decision(self, item: DetectedItem) -> Tuple[str, str, bool]:
        """Make sorting decision with natural, conversational style"""
        phase = self.get_learning_phase()
        color = item.color
        base_color = color.split('#')[0] if '#' in color else color
        clothing_type = color.split('#')[1] if '#' in color else 'item'
        
        # Check if we've learned this color before
        learned_category = self.database["laundry_data"]["learning_database"].get(base_color)
        
        if phase == "learning":
            # Learning phase - casual questions
            if learned_category:
                casual_checks = [
                    f"I remember putting {base_color} stuff in {learned_category} before.",
                    f"Last {base_color} item went in {learned_category}.",
                    f"You usually put {base_color} things in {learned_category}.",
                    f"I think {base_color} items go in {learned_category}."
                ]
                print(f"🤔 {random.choice(casual_checks)}")
                print(f"Same deal for this {clothing_type}? (y/n)")
                
                confirm = input("> ").strip().lower()
                if confirm in ['y', 'yes']:
                    return learned_category, "following your pattern", False
            
            new_item_responses = [
                f"Hmm, first {base_color} {clothing_type} I've seen!",
                f"New one for me - {base_color} {clothing_type}.",
                f"Haven't sorted a {base_color} {clothing_type} before.",
                f"This {base_color} {clothing_type} is new to me."
            ]
            print(f"🤷‍♂️ {random.choice(new_item_responses)}")
            print("Where should it go?")
            print("   1) Lights")
            print("   2) Darks") 
            print("   3) Colors")
            
            while True:
                user_choice = input("> ").strip()
                if user_choice == "1" or user_choice.lower() == "lights":
                    return "Lights", "you taught me", True
                elif user_choice == "2" or user_choice.lower() == "darks":
                    return "Darks", "you taught me", True
                elif user_choice == "3" or user_choice.lower() == "colors":
                    return "Colors", "you taught me", True
                else:
                    print("Choose 1 (Lights), 2 (Darks), or 3 (Colors)")
                
        elif phase == "tentative":
            # Tentative phase - confident suggestions
            if learned_category:
                suggestion_phrases = [
                    f"Based on your style, this probably goes in {learned_category}.",
                    f"You usually put {base_color} items in {learned_category}.",
                    f"Following your pattern, I'd say {learned_category}.",
                    f"Looks like a {learned_category} item to me."
                ]
                print(f"🤖 {random.choice(suggestion_phrases)}")
            else:
                suggested = self.get_default_category(color)
                reasoning = self.get_cori_reasoning(color, suggested)
                print(f"🤖 I'm thinking {suggested}.")
                print(f"💭 {reasoning}")
                learned_category = suggested
            
            confirm_phrases = ["Sound right?", "Good?", "Agree?", "Make sense?"]
            print(f"{random.choice(confirm_phrases)} (y/n)")
            confirm = input("> ").strip().lower()
            if confirm in ['y', 'yes']:
                return learned_category, "following my suggestion", False
            else:
                print("🤔 Okay, where would you put it?")
                print("   1) Lights")
                print("   2) Darks")
                print("   3) Colors")
                while True:
                    user_choice = input("> ").strip()
                    if user_choice == "1" or user_choice.lower() == "lights":
                        correction_reason = input("Why there? ").strip()
                        self.record_correction(base_color, learned_category, "Lights", correction_reason)
                        return "Lights", f"you corrected me: {correction_reason}", True
                    elif user_choice == "2" or user_choice.lower() == "darks":
                        correction_reason = input("Why there? ").strip()
                        self.record_correction(base_color, learned_category, "Darks", correction_reason)
                        return "Darks", f"you corrected me: {correction_reason}", True
                    elif user_choice == "3" or user_choice.lower() == "colors":
                        correction_reason = input("Why there? ").strip()
                        self.record_correction(base_color, learned_category, "Colors", correction_reason)
                        return "Colors", f"you corrected me: {correction_reason}", True
                    else:
                        print("Choose 1 (Lights), 2 (Darks), or 3 (Colors)")
        
        else:  # confident phase
            # Confident phase - make decisions with style
            if learned_category:
                confident_statements = [
                    f"Easy - {learned_category}!",
                    f"This goes in {learned_category} for sure.",
                    f"Definitely {learned_category}.",
                    f"{learned_category}, no question."
                ]
                print(f"✅ {random.choice(confident_statements)}")
                print(f"💭 That's where all your {base_color} items go.")
                suggested = learned_category
                reason = "following your established pattern"
            else:
                suggested = self.get_default_category(color)
                reasoning = self.get_cori_reasoning(color, suggested)
                confident_statements = [
                    f"I'm putting this in {suggested}.",
                    f"This belongs in {suggested}.",
                    f"{suggested} is the right choice.",
                    f"Going with {suggested} on this one."
                ]
                print(f"✅ {random.choice(confident_statements)}")
                print(f"💭 {reasoning}")
                reason = reasoning
            
            override_checks = ["Different idea?", "Change of plans?", "Override?"]
            print(f"{random.choice(override_checks)} (y/n)")
            override = input("> ").strip().lower()
            if override in ['y', 'yes']:
                print("Where instead?")
                print("   1) Lights")
                print("   2) Darks")
                print("   3) Colors")
                while True:
                    user_choice = input("> ").strip()
                    if user_choice == "1" or user_choice.lower() == "lights":
                        correction_reason = input("Why there? ").strip()
                        self.record_correction(base_color, suggested, "Lights", correction_reason)
                        return "Lights", f"you corrected me: {correction_reason}", True
                    elif user_choice == "2" or user_choice.lower() == "darks":
                        correction_reason = input("Why there? ").strip()
                        self.record_correction(base_color, suggested, "Darks", correction_reason)
                        return "Darks", f"you corrected me: {correction_reason}", True
                    elif user_choice == "3" or user_choice.lower() == "colors":
                        correction_reason = input("Why there? ").strip()
                        self.record_correction(base_color, suggested, "Colors", correction_reason)
                        return "Colors", f"you corrected me: {correction_reason}", True
                    else:
                        print("Choose 1 (Lights), 2 (Darks), or 3 (Colors)")
            else:
                return suggested, reason, False
    
    def record_correction(self, color: str, wrong_category: str, right_category: str, reason: str):
        """Record when user corrects CORI's decision with natural feedback"""
        correction = {
            "color": color,
            "wrong_category": wrong_category,
            "right_category": right_category,
            "reason": reason,
            "timestamp": time.time()
        }
        
        self.database["laundry_data"]["user_corrections"].append(correction)
        self.database["laundry_data"]["learning_database"][color] = right_category
        
        # More natural responses
        responses = [
            f"Ah, got it! {color.title()} items go in {right_category}. I'll remember that.",
            f"Thanks for the correction! {color.title()} → {right_category}. Makes sense!",
            f"Good to know! I'll put {color} items in {right_category} from now on.",
            f"Perfect! {color.title()} goes in {right_category}. Learning something new!"
        ]
        
        print(f"📝 {random.choice(responses)}")
    
    def update_laundry_counts(self, category: str, item: DetectedItem):
        """Update hamper counts and learning database"""
        base_color = item.color.split('#')[0] if '#' in item.color else item.color
        item_name = item.color.replace('#', ' ').title()
        
        # Update counts
        self.database["laundry_data"]["hamper_counts"][category] += 1
        self.database["laundry_data"]["total_items_sorted"] += 1
        
        # Update learning database
        self.database["laundry_data"]["learning_database"][base_color] = category
        
        # Track sorted items history for hamper contents
        if "sorted_items_history" not in self.database["laundry_data"]:
            self.database["laundry_data"]["sorted_items_history"] = []
        
        item_record = {
            "item_name": item_name,
            "category": category,
            "timestamp": item.timestamp,
            "color": base_color
        }
        
        self.database["laundry_data"]["sorted_items_history"].append(item_record)
        
        self.save_database()
    
    def generate_sorting_report(self, item: DetectedItem, category: str, reason: str):
        """Generate natural sorting report"""
        clothing_name = item.color.replace('#', ' ').title()
        
        # Natural completion messages
        completion_messages = [
            f"Done! The {clothing_name} is now in the {category} hamper.",
            f"Perfect! {clothing_name} → {category} hamper.",
            f"All set! Your {clothing_name} is sorted into {category}.",
            f"There we go! {clothing_name} goes in {category}."
        ]
        
        print(f"\n{random.choice(completion_messages)}")
        if reason and not reason.startswith("following"):
            print(f"💡 {reason}")
        
        # Show updated counts more naturally
        counts = self.database["laundry_data"]["hamper_counts"]
        total = sum(counts.values())
        
        print(f"\n📊 Current hampers: Lights({counts['Lights']}) | Darks({counts['Darks']}) | Colors({counts['Colors']})")
        
        # Show learning progress naturally
        phase = self.get_learning_phase()
        if phase == "learning" and total < 15:
            remaining_to_learn = 15 - total
            remaining_text = "item" if remaining_to_learn == 1 else "items"
            print(f"🧠 Still learning your style! ({remaining_to_learn} more {remaining_text} until I get more confident)")
        elif phase == "tentative" and total < 30:
            remaining_to_confident = 30 - total
            remaining_text = "item" if remaining_to_confident == 1 else "items"
            print(f"🤖 Getting the hang of this! ({remaining_to_confident} more {remaining_text} until I'm fully confident)")
        elif total == 15:
            print(f"🎉 I'm starting to understand your preferences! Moving to suggestion mode.")
        elif total == 30:
            print(f"🎓 I've got your laundry style down! I'll make confident decisions now.")
    
    def show_hamper_contents(self, hamper_name: str):
        """Show contents of a specific hamper"""
        # Get all items from the sorting history that went to this hamper
        items_in_hamper = []
        
        if "sorted_items_history" not in self.database["laundry_data"]:
            self.database["laundry_data"]["sorted_items_history"] = []
        
        for item_record in self.database["laundry_data"]["sorted_items_history"]:
            if item_record.get("category") == hamper_name:
                items_in_hamper.append(item_record)
        
        print(f"\n📦 {hamper_name.upper()} HAMPER:")
        
        # Check the hamper count vs history
        hamper_count = self.database["laundry_data"]["hamper_counts"].get(hamper_name, 0)
        
        if hamper_count == 0:
            print(f"   Empty - no {hamper_name.lower()} items sorted yet")
        elif not items_in_hamper and hamper_count > 0:
            items_text = "item" if hamper_count == 1 else "items"
            print(f"   {hamper_count} {items_text} (sorted before detailed tracking was enabled)")
            print(f"   Start sorting new items to see detailed history!")
        else:
            items_text = "item" if len(items_in_hamper) == 1 else "items"
            print(f"   {len(items_in_hamper)} {items_text}:")
            for i, item in enumerate(items_in_hamper[-10:], 1):  # Show last 10 items
                item_name = item.get("item_name", "Unknown item")
                timestamp = item.get("timestamp", 0)
                # Convert timestamp to readable format
                time_str = datetime.datetime.fromtimestamp(timestamp).strftime("%m/%d %H:%M")
                print(f"   {i}. {item_name} (sorted {time_str})")
            
            if len(items_in_hamper) > 10:
                remaining_items = len(items_in_hamper) - 10
                remaining_text = "item" if remaining_items == 1 else "items"
                print(f"   ... and {remaining_items} more {remaining_text}")
            
            # Show if there are items not in detailed history
            if hamper_count > len(items_in_hamper):
                missing_items = hamper_count - len(items_in_hamper)
                missing_text = "item" if missing_items == 1 else "items"
                print(f"   ... plus {missing_items} {missing_text} from before detailed tracking")
    
    def show_all_hamper_contents(self):
        """Show contents of all hampers"""
        print(f"\n📋 ALL HAMPER CONTENTS:")
        
        for hamper in ["Lights", "Darks", "Colors"]:
            self.show_hamper_contents(hamper)
            print()  # Add spacing between hampers
    
    def run_laundry_assistant(self):
        """Execute the complete CORI laundry sorting workflow with cool startup"""
        # Show the awesome startup sequence first
        detected_item = self.show_startup_sequence()
        
        if detected_item is None:
            goodbye_messages = [
                "👋 Thanks for checking out C.O.R.I.! See you later!",
                "🤖 Goodbye! Come back anytime you need help sorting!",
                "✨ Catch you later! Keep those clothes organized!",
                "🧺 See ya! C.O.R.I. will be here when you need me!"
            ]
            print(f"\n{random.choice(goodbye_messages)}")
            return
        
        items_since_last_break = 0
        
        while True:
            # If we don't have a detected item, get one
            if detected_item is None:
                detected_item = self.detect_clothing_item()
                
            if detected_item is None:
                print("\n👋 Thanks for using C.O.R.I.! See you next time!")
                break
            
            # Step 2: Sorting Decision
            category, reason, was_corrected = self.make_sorting_decision(detected_item)
            
            # Step 3: Update Database
            self.update_laundry_counts(category, detected_item)
            
            # Step 4: Generate Report
            self.generate_sorting_report(detected_item, category, reason)
            
            # Step 5: Track items since last break
            items_since_last_break += 1
            
            # Reset detected_item for next iteration
            detected_item = None
            
            # Ask if user wants to continue - every 10 items or when they want to stop
            total_sorted = self.database["laundry_data"]["total_items_sorted"]
            
            if items_since_last_break >= 10:
                # Every 10 items, ask if they want to keep going
                items_text = "item" if items_since_last_break == 1 else "items"
                print(f"\n🎉 Great job! We've sorted {items_since_last_break} {items_text} in this session.")
                print("Want to keep going with more items?")
                print("   1) Yes, keep sorting!")
                print("   2) Take a break (back to menu)")
                print("   3) Quit for now")
                
                continue_choice = input("> ").strip()
                if continue_choice in ['1', 'yes', 'y', 'keep going']:
                    items_since_last_break = 0  # Reset counter
                    print("\n🚀 Let's keep sorting!")
                elif continue_choice in ['2', 'menu', 'break']:
                    # Return to main menu instead of ending
                    session_text = "item" if items_since_last_break == 1 else "items"
                    print(f"\n📊 Session summary: {items_since_last_break} {session_text} sorted!")
                    items_since_last_break = 0  # Reset counter
                    detected_item = self.show_main_menu()  # Go back to main menu
                    if detected_item is None:
                        break
                else:
                    print("\n👋 Thanks for sorting with C.O.R.I. today!")
                    break
            else:
                # For the first few items, don't ask every time - just continue
                print()  # Just add a space and continue

def main():
    """Main function to run the CORI laundry assistant"""
    assistant = CORILaundryAssistant()
    
    try:
        assistant.run_laundry_assistant()
    except KeyboardInterrupt:
        # Natural goodbye messages instead of robotic interruption message
        goodbye_messages = [
            "\n\n👋 Okay, see ya! Thanks for sorting with me!",
            "\n\n🙌 Goodbye! Catch you later for more laundry fun!",
            "\n\n👋 See you next time! Happy laundry day!",
            "\n\n🧺 Bye! Thanks for teaching me your sorting style!",
            "\n\n✨ Later! Keep those clothes organized!"
        ]
        print(f"{random.choice(goodbye_messages)}")
    except Exception as e:
        print(f"\n❌ Oops, something went wrong: {e}")
        print("👋 But hey, thanks for using C.O.R.I. anyway!")

if __name__ == "__main__":
    main()
=== ./src/cori_cv/cori_cv/nodes/laundry_color_detector.py ===
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image, CameraInfo
from geometry_msgs.msg import PoseStamped, Point
from std_msgs.msg import String, Bool, Int32
from cv_bridge import CvBridge
import cv2
import numpy as np
import time
import json
from collections import deque
import threading
import queue

class ProductionLaundryDetector(Node):
    def __init__(self):
        super().__init__('laundry_detector')
        self.get_logger().info('Professional Laundry Detector starting...')
        
        # Core components
        self.bridge = CvBridge()
        self.setup_parameters()
        self.setup_vision_pipeline()
        self.setup_robot_interface()
        self.setup_performance_monitoring()
        
        # ROS interfaces
        self.setup_ros_interfaces()
        
        self.get_logger().info('Laundry Detector ready')

    def setup_parameters(self):
        """Production parameters - simple and effective"""
        self.declare_parameter('detection_fps', 10.0)
        self.declare_parameter('min_area', 3000)
        self.declare_parameter('max_area', 50000)
        self.declare_parameter('confidence_threshold', 0.75)
        self.declare_parameter('use_background_subtraction', True)
        self.declare_parameter('color_stability_frames', 5)
        
        self.detection_fps = self.get_parameter('detection_fps').value
        self.min_area = self.get_parameter('min_area').value
        self.max_area = self.get_parameter('max_area').value
        self.confidence_threshold = self.get_parameter('confidence_threshold').value
        self.use_background_subtraction = self.get_parameter('use_background_subtraction').value
        self.color_stability_frames = self.get_parameter('color_stability_frames').value

    def setup_vision_pipeline(self):
        """Efficient vision pipeline"""
        # Background subtraction for motion detection
        self.bg_subtractor = cv2.createBackgroundSubtractorMOG2(
            history=500, varThreshold=16, detectShadows=True
        )
        
        # Color analysis
        self.color_history = deque(maxlen=self.color_stability_frames)
        
        # Frame management
        self.latest_rgb = None
        self.latest_depth = None
        self.frame_count = 0
        self.last_detection_time = 0
        
        # Detection state
        self.current_detections = []
        self.pick_queue = queue.Queue()
        self.processing_lock = threading.Lock()

    def setup_robot_interface(self):
        """Simple robot interface"""
        self.robot_busy = False
        self.pick_success_rate = 0.85
        self.items_processed = 0
        self.session_start = time.time()

    def setup_performance_monitoring(self):
        """Performance tracking"""
        self.frame_times = deque(maxlen=50)
        self.detection_times = deque(maxlen=50)
        self.avg_fps = 0.0
        self.shutdown_requested = False

    def setup_ros_interfaces(self):
        """Clean ROS interface"""
        # Inputs
        self.rgb_sub = self.create_subscription(
            Image, '/camera/color/image_raw', self.rgb_callback, 10)
        self.depth_sub = self.create_subscription(
            Image, '/camera/depth/image_raw', self.depth_callback, 10)
        
        # Outputs
        self.pick_target_pub = self.create_publisher(PoseStamped, '/pick_target', 5)
        self.sort_command_pub = self.create_publisher(String, '/sort_command', 5)
        self.status_pub = self.create_publisher(String, '/detector_status', 5)
        
        # Control
        self.start_sub = self.create_subscription(Bool, '/start_sorting', self.start_callback, 1)
        self.robot_status_sub = self.create_subscription(String, '/robot_status', self.robot_status_callback, 5)
        
        # Main processing timer
        detection_period = 1.0 / self.detection_fps
        self.detection_timer = self.create_timer(detection_period, self.detection_callback)
        self.display_timer = self.create_timer(0.033, self.display_callback)  # 30 FPS display

    def rgb_callback(self, msg):
        """High-performance RGB processing"""
        if self.shutdown_requested:
            return
            
        try:
            frame = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            
            # Basic preprocessing
            frame = cv2.bilateralFilter(frame, 5, 50, 50)  # Noise reduction
            
            with self.processing_lock:
                self.latest_rgb = frame
                self.frame_count += 1
                
        except Exception as e:
            if not self.shutdown_requested:
                self.get_logger().error(f"RGB callback error: {e}")

    def depth_callback(self, msg):
        """Efficient depth processing"""
        if self.shutdown_requested:
            return
            
        try:
            depth = self.bridge.imgmsg_to_cv2(msg, desired_encoding='16UC1')
            
            # Convert to meters and filter
            depth_m = depth.astype(np.float32) / 1000.0
            depth_m[depth_m == 0] = np.nan
            depth_m[depth_m > 1.5] = np.nan  # 1.5m max range
            
            with self.processing_lock:
                self.latest_depth = depth_m
                
        except Exception as e:
            if not self.shutdown_requested:
                self.get_logger().error(f"Depth callback error: {e}")

    def detection_callback(self):
        """Main detection processing - optimized for speed"""
        if self.shutdown_requested:
            return
            
        start_time = time.time()
        
        # Skip if no new frames or robot is busy
        if self.latest_rgb is None or self.robot_busy:
            return
        
        with self.processing_lock:
            rgb_frame = self.latest_rgb.copy()
            depth_frame = self.latest_depth.copy() if self.latest_depth is not None else None
        
        # Detect garments
        detections = self.detect_garments(rgb_frame, depth_frame)
        
        # Process detections
        if detections:
            # Sort by confidence and pickability
            detections.sort(key=lambda x: x['total_score'], reverse=True)
            
            # Update current detections
            self.current_detections = detections
            
            # Send pick command for best target
            if not self.robot_busy and detections[0]['total_score'] > self.confidence_threshold:
                self.send_pick_command(detections[0])
        
        # Performance tracking
        detection_time = time.time() - start_time
        self.detection_times.append(detection_time)
        self.last_detection_time = time.time()
        
        # Update FPS
        if self.frame_times:
            self.avg_fps = len(self.frame_times) / sum(self.frame_times)

    def detect_garments(self, rgb_frame, depth_frame):
        """Efficient garment detection"""
        detections = []
        
        # Method 1: Background subtraction for new items
        if self.use_background_subtraction:
            motion_detections = self.detect_motion_objects(rgb_frame)
            detections.extend(motion_detections)
        
        # Method 2: Static detection for existing items
        static_detections = self.detect_static_objects(rgb_frame, depth_frame)
        detections.extend(static_detections)
        
        # Remove duplicates
        detections = self.remove_overlapping_detections(detections)
        
        return detections

    def detect_motion_objects(self, frame):
        """Fast motion-based detection"""
        # Apply background subtraction
        fg_mask = self.bg_subtractor.apply(frame)
        
        # Remove shadows
        fg_mask[fg_mask == 127] = 0
        
        # Morphological cleanup
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
        fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_CLOSE, kernel)
        fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_OPEN, kernel)
        
        # Find contours
        contours, _ = cv2.findContours(fg_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        detections = []
        for contour in contours:
            detection = self.analyze_contour(contour, frame, 'motion')
            if detection:
                detections.append(detection)
        
        return detections

    def detect_static_objects(self, frame, depth_frame):
        """Efficient static object detection"""
        detections = []
        
        # Edge detection
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        edges = cv2.Canny(gray, 50, 150)
        
        # Morphological operations
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
        edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)
        
        # Find contours
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        for contour in contours:
            detection = self.analyze_contour(contour, frame, 'static', depth_frame)
            if detection:
                detections.append(detection)
        
        return detections

    def analyze_contour(self, contour, frame, detection_type, depth_frame=None):
        """Fast contour analysis"""
        # Basic filtering
        area = cv2.contourArea(contour)
        if area < self.min_area or area > self.max_area:
            return None
        
        # Bounding rectangle
        x, y, w, h = cv2.boundingRect(contour)
        
        # Aspect ratio check
        aspect_ratio = w / h
        if aspect_ratio > 4 or aspect_ratio < 0.25:
            return None
        
        # Extract region of interest
        roi = frame[y:y+h, x:x+w]
        if roi.size == 0:
            return None
        
        # Color analysis
        color_result = self.analyze_color_fast(roi)
        
        # Depth analysis (if available)
        depth_score = 0.5
        pickable_point = None
        
        if depth_frame is not None:
            depth_result = self.analyze_depth_fast(x, y, w, h, depth_frame)
            depth_score = depth_result['confidence']
            pickable_point = depth_result['pick_point']
        
        # Shape analysis
        shape_score = self.analyze_shape_fast(contour, area, w, h)
        
        # Detection type bonus
        type_bonus = 0.2 if detection_type == 'motion' else 0.0
        
        # Total confidence
        total_score = (color_result['confidence'] * 0.4 + 
                      depth_score * 0.3 + 
                      shape_score * 0.2 + 
                      type_bonus * 0.1)
        
        return {
            'contour': contour,
            'bbox': (x, y, w, h),
            'area': area,
            'color_name': color_result['color_name'],
            'pile': color_result['pile'],
            'color_confidence': color_result['confidence'],
            'depth_score': depth_score,
            'shape_score': shape_score,
            'total_score': total_score,
            'detection_type': detection_type,
            'pickable_point': pickable_point
        }

    def analyze_color_fast(self, roi):
        """Fast color analysis"""
        # Sample center region
        h, w = roi.shape[:2]
        center_h, center_w = h//2, w//2
        sample_size = min(w//4, h//4, 15)
        
        if sample_size < 3:
            center_roi = roi
        else:
            center_roi = roi[center_h-sample_size:center_h+sample_size,
                           center_w-sample_size:center_w+sample_size]
        
        # Get dominant color
        pixels = center_roi.reshape(-1, 3)
        dominant_color = np.median(pixels, axis=0).astype(int)
        
        # Classify color
        return self.classify_color_production(dominant_color)

    def classify_color_production(self, bgr_color):
        """Production color classification - fast and reliable"""
        # Convert to HSV
        hsv = cv2.cvtColor(np.uint8([[bgr_color]]), cv2.COLOR_BGR2HSV)[0][0]
        h, s, v = hsv
        
        confidence = 0.8  # Base confidence
        
        # White detection
        if s < 25 and v > 180:
            return {'color_name': 'white', 'pile': 'lights', 'confidence': 0.95}
        
        # Black detection
        if v < 50:
            return {'color_name': 'black', 'pile': 'darks', 'confidence': 0.9}
        
        # Gray detection
        if s < 35:
            if v > 140:
                return {'color_name': 'light_gray', 'pile': 'lights', 'confidence': 0.85}
            else:
                return {'color_name': 'gray', 'pile': 'darks', 'confidence': 0.85}
        
        # Color classification
        hue_360 = h * 2
        
        # Define color ranges
        if hue_360 < 20 or hue_360 >= 340:
            color_name, pile = 'red', 'colors'
        elif 20 <= hue_360 < 45:
            color_name, pile = 'orange', 'colors'
        elif 45 <= hue_360 < 65:
            # Yellow special case
            if v > 150:
                color_name, pile = 'yellow', 'lights'
            else:
                color_name, pile = 'yellow', 'colors'
        elif 65 <= hue_360 < 120:
            color_name, pile = 'green', 'colors'
        elif 120 <= hue_360 < 180:
            color_name, pile = 'cyan', 'colors'
        elif 180 <= hue_360 < 240:
            if v < 80:  # Dark blue
                color_name, pile = 'navy', 'darks'
            else:
                color_name, pile = 'blue', 'colors'
        elif 240 <= hue_360 < 300:
            if v < 90:  # Dark purple
                color_name, pile = 'purple', 'darks'
            else:
                color_name, pile = 'purple', 'colors'
        else:
            color_name, pile = 'pink', 'colors'
        
        # Adjust confidence based on saturation
        if s > 100:
            confidence = 0.9
        elif s < 50:
            confidence = 0.6
        
        return {'color_name': color_name, 'pile': pile, 'confidence': confidence}

    def analyze_depth_fast(self, x, y, w, h, depth_frame):
        """Fast depth analysis"""
        # Extract depth ROI
        depth_roi = depth_frame[y:y+h, x:x+w]
        valid_depths = depth_roi[~np.isnan(depth_roi)]
        
        if len(valid_depths) == 0:
            return {'confidence': 0.3, 'pick_point': None}
        
        # Calculate depth statistics
        mean_depth = np.mean(valid_depths)
        min_depth = np.min(valid_depths)  # Closest point (highest)
        depth_variance = np.var(valid_depths)
        
        # Confidence based on depth quality
        if depth_variance < 0.01:  # Good depth consistency
            confidence = 0.9
        elif depth_variance < 0.05:
            confidence = 0.7
        else:
            confidence = 0.4
        
        # Pick point at center of highest region
        center_x = x + w // 2
        center_y = y + h // 2
        pick_point = self.pixel_to_world(center_x, center_y, min_depth)
        
        return {'confidence': confidence, 'pick_point': pick_point}

    def analyze_shape_fast(self, contour, area, w, h):
        """Fast shape analysis"""
        # Aspect ratio score
        aspect_ratio = w / h
        if 0.5 <= aspect_ratio <= 2.0:  # Reasonable clothing ratios
            aspect_score = 1.0
        else:
            aspect_score = 0.5
        
        # Solidity score
        hull = cv2.convexHull(contour)
        hull_area = cv2.contourArea(hull)
        solidity = area / hull_area if hull_area > 0 else 0
        
        if solidity > 0.6:  # Reasonably solid
            solidity_score = 1.0
        else:
            solidity_score = 0.6
        
        return (aspect_score + solidity_score) / 2

    def pixel_to_world(self, u, v, depth):
        """Simple pixel to world conversion"""
        # Simplified camera parameters
        fx, fy = 525.0, 525.0  # Replace with actual calibration
        cx, cy = 320.0, 240.0
        
        x = (u - cx) * depth / fx
        y = (v - cy) * depth / fy
        z = depth
        
        return [x, y, z]

    def remove_overlapping_detections(self, detections):
        """Remove overlapping detections"""
        if len(detections) <= 1:
            return detections
        
        # Sort by confidence
        detections.sort(key=lambda x: x['total_score'], reverse=True)
        
        filtered = []
        for detection in detections:
            x1, y1, w1, h1 = detection['bbox']
            
            overlap = False
            for existing in filtered:
                x2, y2, w2, h2 = existing['bbox']
                
                # Calculate overlap
                overlap_x = max(0, min(x1 + w1, x2 + w2) - max(x1, x2))
                overlap_y = max(0, min(y1 + h1, y2 + h2) - max(y1, y2))
                overlap_area = overlap_x * overlap_y
                
                union_area = w1 * h1 + w2 * h2 - overlap_area
                iou = overlap_area / union_area if union_area > 0 else 0
                
                if iou > 0.3:  # 30% overlap threshold
                    overlap = True
                    break
            
            if not overlap:
                filtered.append(detection)
        
        return filtered

    def send_pick_command(self, detection):
        """Send pick command to robot"""
        if detection['pickable_point'] is None:
            return
        
        # Create pose message
        pose_msg = PoseStamped()
        pose_msg.header.stamp = self.get_clock().now().to_msg()
        pose_msg.header.frame_id = 'base_link'
        
        pick_point = detection['pickable_point']
        pose_msg.pose.position.x = pick_point[0]
        pose_msg.pose.position.y = pick_point[1]
        pose_msg.pose.position.z = pick_point[2] - 0.03  # Approach from 3cm above
        
        # Default orientation (gripper pointing down)
        pose_msg.pose.orientation.w = 1.0
        
        # Publish pick target
        self.pick_target_pub.publish(pose_msg)
        
        # Publish sort command
        sort_msg = String()
        sort_msg.data = detection['pile']
        self.sort_command_pub.publish(sort_msg)
        
        # Update state
        self.robot_busy = True
        
        self.get_logger().info(f"Pick command sent: {detection['color_name']} -> {detection['pile']} "
                              f"(confidence: {detection['total_score']:.2f})")

    def start_callback(self, msg):
        """Start/stop sorting"""
        if msg.data:
            self.get_logger().info("Starting laundry sorting operation")
            self.session_start = time.time()
            self.items_processed = 0
        else:
            self.get_logger().info("Stopping laundry sorting operation")

    def robot_status_callback(self, msg):
        """Handle robot status updates"""
        status = msg.data
        
        if status == 'pick_complete':
            self.robot_busy = False
            self.items_processed += 1
            self.get_logger().info(f"Pick completed. Total items: {self.items_processed}")
        elif status == 'pick_failed':
            self.robot_busy = False
            self.get_logger().warn("Pick operation failed")
        elif status in ['moving', 'picking', 'sorting']:
            self.robot_busy = True

    def display_callback(self):
        """Display results - NO WINDOW VERSION"""
        if self.latest_rgb is None or self.shutdown_requested:
            return
        
        # Just log detection info instead of showing window
        if self.current_detections:
            for i, detection in enumerate(self.current_detections):
                if i == 0:  # Only log the best detection
                    self.get_logger().info(f"DETECTED: {detection['color_name'].upper()} -> {detection['pile'].upper()} (conf: {detection['total_score']:.2f})")
        
        # Check for shutdown via parameter instead of keyboard
        return

    def draw_detection(self, frame, detection, is_primary=False):
        """Draw detection visualization"""
        contour = detection['contour']
        x, y, w, h = detection['bbox']
        
        # Color coding
        if detection['total_score'] > 0.8:
            color = (0, 255, 0)  # Green - high confidence
        elif detection['total_score'] > 0.6:
            color = (0, 255, 255)  # Yellow - medium confidence
        else:
            color = (0, 165, 255)  # Orange - low confidence
        
        thickness = 3 if is_primary else 2
        
        # Draw contour
        cv2.drawContours(frame, [contour], -1, color, thickness)
        
        # Draw bounding box
        cv2.rectangle(frame, (x, y), (x + w, y + h), color, 1)
        
        # Label
        label = f"{detection['color_name'].upper()} -> {detection['pile'].upper()}"
        conf_label = f"Conf: {detection['total_score']:.2f}"
        type_label = f"Type: {detection['detection_type']}"
        
        # Label background
        labels = [label, conf_label, type_label]
        max_width = max([cv2.getTextSize(l, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)[0][0] for l in labels])
        
        bg_height = len(labels) * 20 + 10
        cv2.rectangle(frame, (x, y - bg_height), (x + max_width + 10, y), (0, 0, 0), -1)
        
        # Draw text
        for i, text in enumerate(labels):
            cv2.putText(frame, text, (x + 5, y - bg_height + 20 + i * 18), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

    def draw_status(self, frame):
        """Draw system status"""
        h, w = frame.shape[:2]
        
        # Status panel
        panel_h = 100
        overlay = frame.copy()
        cv2.rectangle(overlay, (0, 0), (w, panel_h), (0, 0, 0), -1)
        cv2.addWeighted(overlay, 0.7, frame, 0.3, 0, frame)
        
        # Status text
        status_lines = [
            f"Production Laundry Detector v1.0",
            f"FPS: {self.avg_fps:.1f} | Detections: {len(self.current_detections)}",
            f"Items Processed: {self.items_processed} | Robot: {'BUSY' if self.robot_busy else 'READY'}",
            f"Session Time: {time.time() - self.session_start:.0f}s"
        ]
        
        for i, line in enumerate(status_lines):
            cv2.putText(frame, line, (10, 25 + i * 20), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)
        
        # Performance indicators
        indicators = [
            ('RGB', (0, 255, 0) if self.latest_rgb is not None else (0, 0, 255)),
            ('DEPTH', (0, 255, 0) if self.latest_depth is not None else (0, 0, 255)),
            ('ROBOT', (0, 255, 0) if not self.robot_busy else (255, 255, 0))
        ]
        
        for i, (name, color) in enumerate(indicators):
            x = w - 200 + i * 60
            cv2.circle(frame, (x, 30), 8, color, -1)
            cv2.putText(frame, name, (x - 15, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 255), 1)

    def publish_status(self):
        """Publish system status"""
        status = {
            'detections': len(self.current_detections),
            'items_processed': self.items_processed,
            'robot_busy': self.robot_busy,
            'avg_fps': self.avg_fps,
            'session_time': time.time() - self.session_start
        }
        
        status_msg = String()
        status_msg.data = json.dumps(status)
        self.status_pub.publish(status_msg)

    def destroy_node(self):
        """Clean shutdown of the node"""
        try:
            self.get_logger().info("Cleaning up resources...")
            self.shutdown_requested = True
            
            # Stop timers
            if hasattr(self, 'detection_timer'):
                self.detection_timer.cancel()
            if hasattr(self, 'display_timer'):
                self.display_timer.cancel()
            
            # Clean up OpenCV
            cv2.destroyAllWindows()
            
            # Call parent destroy
            super().destroy_node()
            
        except Exception as e:
            print(f"Error during node cleanup: {e}")

def main():
    rclpy.init()
    detector = ProductionLaundryDetector()
    
    try:
        # Check for shutdown request in the spin loop
        while rclpy.ok() and not detector.shutdown_requested:
            rclpy.spin_once(detector, timeout_sec=0.1)
        
        if detector.shutdown_requested:
            detector.get_logger().info("Shutting down gracefully...")
            
    except KeyboardInterrupt:
        detector.get_logger().info("Keyboard interrupt")
    except Exception as e:
        detector.get_logger().error(f"Unexpected error: {e}")
    finally:
        try:
            detector.destroy_node()
        except Exception as e:
            print(f"Error destroying node: {e}")
        
        try:
            if rclpy.ok():
                rclpy.shutdown()
        except Exception as e:
            print(f"Error during RCL shutdown: {e}")

if __name__ == '__main__':
    main()
=== ./src/cori_cv/cori_cv/nodes/__init__.py ===
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2
import numpy as np
import threading
import time


class ColorClassifier:
    def __init__(self):
        pass

    def get_color_name(self, bgr):
        hsv = cv2.cvtColor(np.uint8([[bgr]]), cv2.COLOR_BGR2HSV)[0][0]
        h, s, v = hsv

        if v < 50:
            return 'black'
        if s < 50 and v > 200:
            return 'white'
        if s < 50:
            return 'gray'

        if h < 10 or h >= 170:
            return 'red'
        elif 10 <= h < 25:
            return 'orange'
        elif 25 <= h < 40:
            return 'yellow'
        elif 40 <= h < 85:
            return 'green'
        elif 85 <= h < 130:
            return 'cyan'
        elif 130 <= h < 150:
            return 'blue'
        elif 150 <= h < 170:
            return 'purple'
        return 'unknown'

    def classify_pile(self, color_name):
        if color_name in ['white', 'yellow', 'light_gray']:
            return 'lights'
        elif color_name in ['black', 'navy', 'dark_gray', 'brown', 'gray', 'purple']:
            return 'darks'
        elif color_name in ['red', 'orange', 'green', 'blue', 'cyan', 'pink']:
            return 'colors'
        return 'unknown'


class LaundryColorDetector(Node):
    def __init__(self):
        super().__init__('laundry_color_detector')
        self.get_logger().info('Starting Laundry Color Detector...')

        self.declare_parameter('min_area', 1500)
        self.min_area = self.get_parameter('min_area').value

        self.classifier = ColorClassifier()
        self.bridge = CvBridge()
        self.bg_subtractor = cv2.createBackgroundSubtractorMOG2(history=300, varThreshold=50)

        self.subscription = self.create_subscription(Image, '/image_raw', self.image_callback, 10)
        self.image_buffer = None
        self.class_counts = {'lights': 0, 'darks': 0, 'colors': 0, 'unknown': 0}
        self.font = cv2.FONT_HERSHEY_SIMPLEX

        self.detecting = False
        self.button_state = 'detect'
        self.rerun_button = None
        self.latest_frame = None

        threading.Thread(target=self.display_loop, daemon=True).start()

    def image_callback(self, msg):
        try:
            frame = self.bridge.imgmsg_to_cv2(msg, 'passthrough')
            frame = cv2.cvtColor(frame, cv2.COLOR_YUV2BGR_YUY2)
            self.latest_frame = frame
            if self.detecting:
                self.image_buffer = frame.copy()
        except Exception as e:
            self.get_logger().error(f"Image conversion failed: {e}")

    def start_detection(self):
        if not self.latest_frame.any():
            return

        self.detecting = True
        time.sleep(2)  # Capture buffer
        if self.image_buffer is not None:
            self.process_frame(self.image_buffer)
        self.detecting = False
        self.button_state = 'clear'

    def clear_detection(self):
        self.class_counts = {k: 0 for k in self.class_counts}
        self.button_state = 'detect'
        self.image_buffer = None

    def process_frame(self, frame):
        fg_mask = self.bg_subtractor.apply(frame)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
        fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_OPEN, kernel)
        fg_mask = cv2.dilate(fg_mask, kernel, iterations=1)

        contours, _ = cv2.findContours(fg_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        self.class_counts = {k: 0 for k in self.class_counts}

        for cnt in contours:
            x, y, w, h = cv2.boundingRect(cnt)
            if w * h < self.min_area:
                continue
            roi = frame[y:y+h, x:x+w]
            avg_color = np.mean(roi.reshape(-1, 3), axis=0).astype(np.uint8)
            color_name = self.classifier.get_color_name(avg_color)
            pile = self.classifier.classify_pile(color_name)
            self.class_counts[pile] += 1
            cv2.rectangle(frame, (x, y), (x+w, y+h), tuple(int(c) for c in avg_color), 2)
            cv2.putText(frame, f"{color_name.upper()} -> {pile.upper()}", (x, y - 10), self.font, 0.7, (255, 255, 255), 2)

    def draw_summary_box(self, frame):
        x, y, w, h = 30, 30, 320, 200
        overlay = frame.copy()
        cv2.rectangle(overlay, (x, y), (x + w, y + h), (0, 0, 0), -1)
        cv2.addWeighted(overlay, 0.6, frame, 0.4, 0, frame)

        lines = [
            f"Total Articles: {sum(self.class_counts.values())}",
            f"Lights: {self.class_counts['lights']}",
            f"Darks: {self.class_counts['darks']}",
            f"Colors: {self.class_counts['colors']}",
            f"Unknown: {self.class_counts['unknown']}"
        ]
        for i, line in enumerate(lines):
            cv2.putText(frame, line, (x + 15, y + 35 + i * 30), self.font, 0.8, (255, 255, 255), 2)

    def draw_button(self, frame):
        text = 'DETECT OBJECTS' if self.button_state == 'detect' else 'CLEAR'
        x, y, w, h = frame.shape[1] - 200, frame.shape[0] - 70, 180, 50
        color = (0, 100, 200) if self.button_state == 'detect' else (200, 50, 50)
        cv2.rectangle(frame, (x, y), (x + w, y + h), color, -1, cv2.LINE_AA)
        cv2.putText(frame, text, (x + 10, y + 35), self.font, 0.9, (255, 255, 255), 2)
        self.rerun_button = (x, y, x + w, y + h)

    def on_mouse_click(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN and self.rerun_button:
            x1, y1, x2, y2 = self.rerun_button
            if x1 <= x <= x2 and y1 <= y <= y2:
                if self.button_state == 'detect':
                    threading.Thread(target=self.start_detection, daemon=True).start()
                else:
                    self.clear_detection()

    def display_loop(self):
        while True:
            if self.latest_frame is None:
                continue
            display = self.latest_frame.copy()
            self.draw_summary_box(display)
            self.draw_button(display)
            cv2.imshow('CORI Laundry Sorter [Interactive]', display)
            cv2.setMouseCallback('CORI Laundry Sorter [Interactive]', self.on_mouse_click)
            if cv2.waitKey(30) == 27:
                break

    def destroy_node(self):
        cv2.destroyAllWindows()
        super().destroy_node()


def main():
    rclpy.init()
    node = LaundryColorDetector()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

=== ./src/cori_cv/cori_cv/simple_color_detector.py ===
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import String
from cv_bridge import CvBridge
import cv2
import numpy as np

class SimpleColorDetector(Node):
    def __init__(self):
        super().__init__('simple_color_detector')
        self.get_logger().info('CORI Color Detector Starting...')
        
        # CV Bridge
        self.bridge = CvBridge()
        
        # Subscribe to real webcam
        self.subscription = self.create_subscription(
            Image,
            '/camera/color/image_raw',  # Real webcam topic
            self.image_callback,
            10
        )
        
        # Publisher for color detection results
        self.color_publisher = self.create_publisher(String, '/cori/color_detected', 10)
        
        # Detection variables
        self.last_color = "No Color Detected"
        self.frame_count = 0
        
        self.get_logger().info('Color detector ready! Looking for colors...')

    def image_callback(self, msg):
        try:
            # Convert ROS image to OpenCV
            cv_image = self.bridge.imgmsg_to_cv2(msg, 'bgr8')
            
            # Process every 10th frame for performance
            self.frame_count += 1
            if self.frame_count % 10 != 0:
                return
            
            # Get center region for color detection
            height, width = cv_image.shape[:2]
            center_x, center_y = width // 2, height // 2
            roi_size = 50
            
            # Extract center region
            roi = cv_image[center_y-roi_size:center_y+roi_size, 
                          center_x-roi_size:center_x+roi_size]
            
            if roi.size == 0:
                return
            
            # Get dominant color
            dominant_color = self.get_dominant_color(roi)
            
            # Classify color
            color_name = self.classify_color(dominant_color)
            pile = self.classify_pile(color_name)
            
            # Only publish if color changed
            current_detection = f"{color_name.upper()}"
            if current_detection != self.last_color:
                self.last_color = current_detection
                
                # Publish to ROS topic for Gazebo UI
                color_msg = String()
                color_msg.data = current_detection
                self.color_publisher.publish(color_msg)
                
                # Print to terminal with pile classification
                self.get_logger().info(f"DETECTED: {color_name.upper()} -> {pile.upper()}")
                
        except Exception as e:
            self.get_logger().error(f"Error processing image: {e}")

    def get_dominant_color(self, roi):
        """Get the dominant color in the region of interest"""
        # Reshape to list of pixels
        pixels = roi.reshape(-1, 3)
        
        # Use median for robust color detection
        dominant_color = np.median(pixels, axis=0).astype(int)
        return dominant_color

    def classify_color(self, bgr_color):
        """Classify BGR color to color name - using your existing logic"""
        # Convert to HSV for better color classification
        hsv = cv2.cvtColor(np.uint8([[bgr_color]]), cv2.COLOR_BGR2HSV)[0][0]
        h, s, v = hsv

        # White detection
        if s < 30 and v > 200:
            return 'white'
        
        # Black detection
        if v < 50:
            return 'black'
        
        # Gray detection
        if s < 50:
            return 'gray'

        # Color classification based on hue
        if h < 10 or h >= 170:
            return 'red'
        elif 10 <= h < 25:
            return 'orange'
        elif 25 <= h < 40:
            return 'yellow'
        elif 40 <= h < 85:
            return 'green'
        elif 85 <= h < 130:
            return 'cyan'
        elif 130 <= h < 150:
            return 'blue'
        elif 150 <= h < 170:
            return 'purple'
        
        return 'unknown'

    def classify_pile(self, color_name):
        """Classify color into laundry piles - using your existing logic"""
        if color_name in ['white', 'yellow']:
            return 'lights'
        elif color_name in ['black', 'gray', 'purple']:
            return 'darks'
        elif color_name in ['red', 'orange', 'green', 'blue', 'cyan']:
            return 'colors'
        return 'unknown'

def main():
    rclpy.init()
    node = SimpleColorDetector()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
=== ./src/cori_cv/cori_cv/joint_controller.py ===
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
import math
import time

class InteractiveJointController(Node):
    def __init__(self):
        super().__init__('interactive_joint_controller')
        
        # Publisher for joint states
        self.joint_pub = self.create_publisher(JointState, '/joint_states', 10)
        
        # Timer for publishing joint states
        self.timer = self.create_timer(0.1, self.publish_joints)  # 10 Hz
        
        # Joint positions (you can modify these!)
        self.joint_positions = {
            'head_joint': 0.0,
            'left_shoulder_joint': 0.0,
            'left_elbow_joint': 0.0,
            'left_wrist_joint': 0.0,
            'right_shoulder_joint': 0.0,
            'right_elbow_joint': 0.0,
            'right_wrist_joint': 0.0,
            'left_hip_joint': 0.0,
            'left_knee_joint': 0.0,
            'left_ankle_joint': 0.0,
            'right_hip_joint': 0.0,
            'right_knee_joint': 0.0,
            'right_ankle_joint': 0.0
        }
        
        self.get_logger().info("🤖 CORI Interactive Controller Ready!")
        self.get_logger().info("🎮 Manual control active - move CORI freely!")
        
    def publish_joints(self):
        """Publish current joint states"""
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = list(self.joint_positions.keys())
        msg.position = list(self.joint_positions.values())
        msg.velocity = [0.0] * len(self.joint_positions)
        msg.effort = [0.0] * len(self.joint_positions)
        
        self.joint_pub.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    controller = InteractiveJointController()
    
    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        print("\n🛑 Stopping CORI Controller...")
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()

=== ./src/cori_cv/cori_cv/database_manager.py ===
#!/usr/bin/env python3
"""
CORI Database Manager
Advanced database functions for object management and analytics
"""

import json
import time
import math
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime

@dataclass
class ObjectData:
    """Structured object data for database operations"""
    object_name: str
    primary_location: float  # degrees
    distance: float         # meters
    confidence: float       # 0.0 to 1.0
    last_seen: float       # timestamp
    search_radius: float   # degrees
    success_count: int
    failure_count: int
    world_position: Dict[str, float]  # x, y coordinates
    notes: str = ""
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON storage"""
        return asdict(self)

class CORIDatabaseManager:
    """Advanced database management for CORI spatial object tracking"""
    
    def __init__(self, database_file: str = "../../../database/cori_spatial_database.json"):
        self.database_file = database_file
        self.database = self.load_database()
    
    def load_database(self) -> Dict:
        """Load database with error handling and validation"""
        try:
            with open(self.database_file, 'r') as f:
                db = json.load(f)
            
            # Validate database structure
            if not self._validate_database_structure(db):
                print("⚠️  Database structure validation failed. Creating backup...")
                self._create_backup()
                
            return db
            
        except FileNotFoundError:
            print(f"❌ Database file {self.database_file} not found!")
            return self._create_empty_database()
        except json.JSONDecodeError as e:
            print(f"❌ JSON parsing error: {e}")
            print("Creating backup and starting fresh...")
            self._create_backup()
            return self._create_empty_database()
    
    def _validate_database_structure(self, db: Dict) -> bool:
        """Validate database has required structure"""
        required_keys = ["metadata", "objects"]
        if not all(key in db for key in required_keys):
            return False
        
        # Check metadata
        required_metadata = ["created", "description", "coordinate_system"]
        if not all(key in db["metadata"] for key in required_metadata):
            return False
            
        return True
    
    def _create_empty_database(self) -> Dict:
        """Create a new empty database with proper structure"""
        return {
            "metadata": {
                "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "description": "CORI Spatial Object Database - Maps virtual objects to angular positions",
                "coordinate_system": "Degrees from CORI center (0° = straight ahead, +° = left, -° = right)",
                "total_objects": 0,
                "version": "2.0"
            },
            "objects": {
                "red_objects": [],
                "blue_objects": [],
                "green_objects": [],
                "white_objects": [],
                "black_objects": [],
                "gray_objects": [],
                "orange_objects": []
            }
        }
    
    def _create_backup(self):
        """Create backup of current database"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = self.database_file.replace(".json", f"_backup_{timestamp}.json")
        try:
            with open(self.database_file, 'r') as src, open(backup_file, 'w') as dst:
                dst.write(src.read())
            print(f"💾 Backup created: {backup_file}")
        except Exception as e:
            print(f"❌ Backup failed: {e}")
    
    def save_database(self):
        """Save database with metadata updates"""
        # Update metadata
        self.database["metadata"]["total_objects"] = self.get_total_object_count()
        self.database["metadata"]["last_modified"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        try:
            with open(self.database_file, 'w') as f:
                json.dump(self.database, f, indent=2)
            print("💾 Database saved successfully")
        except Exception as e:
            print(f"❌ Save failed: {e}")
    
    def add_new_object(self, color: str, object_name: str, x: float, y: float, 
                      confidence: float = 0.8, notes: str = "") -> bool:
        """Add a new object to the database"""
        
        # Calculate angular position and distance from world coordinates
        distance = math.sqrt(x**2 + y**2)
        angle = math.degrees(math.atan2(y, x))
        
        # Create object data
        new_object = ObjectData(
            object_name=object_name,
            primary_location=angle,
            distance=distance,
            confidence=confidence,
            last_seen=time.time(),
            search_radius=10.0,
            success_count=0,
            failure_count=0,
            world_position={"x": x, "y": y},
            notes=notes or f"Added via database manager at ({x:.2f}, {y:.2f})"
        )
        
        # Add to appropriate color category
        color_key = f"{color.lower()}_objects"
        if color_key not in self.database["objects"]:
            self.database["objects"][color_key] = []
        
        # Check for duplicates
        existing_names = [obj["object_name"] for obj in self.database["objects"][color_key]]
        if object_name in existing_names:
            print(f"❌ Object '{object_name}' already exists in {color} objects")
            return False
        
        self.database["objects"][color_key].append(new_object.to_dict())
        print(f"✅ Added {object_name} to {color} objects at {angle:.1f}° (distance: {distance:.2f}m)")
        
        self.save_database()
        return True
    
    def remove_object(self, color: str, object_name: str) -> bool:
        """Remove an object from the database"""
        color_key = f"{color.lower()}_objects"
        
        if color_key not in self.database["objects"]:
            print(f"❌ No {color} objects category found")
            return False
        
        objects = self.database["objects"][color_key]
        for i, obj in enumerate(objects):
            if obj["object_name"] == object_name:
                removed_obj = objects.pop(i)
                print(f"✅ Removed {object_name} from {color} objects")
                self.save_database()
                return True
        
        print(f"❌ Object '{object_name}' not found in {color} objects")
        return False
    
    def update_object_success_rate(self, color: str, object_name: str, success: bool):
        """Update object's success/failure statistics"""
        color_key = f"{color.lower()}_objects"
        
        if color_key not in self.database["objects"]:
            return False
        
        for obj in self.database["objects"][color_key]:
            if obj["object_name"] == object_name:
                if success:
                    obj["success_count"] += 1
                else:
                    obj["failure_count"] += 1
                
                # Update confidence based on success rate
                total_attempts = obj["success_count"] + obj["failure_count"]
                success_rate = obj["success_count"] / total_attempts if total_attempts > 0 else 0
                obj["confidence"] = max(0.1, min(0.98, success_rate * 0.9 + 0.1))
                
                obj["last_seen"] = time.time()
                self.save_database()
                return True
        
        return False
    
    def get_objects_by_color(self, color: str) -> List[Dict]:
        """Retrieve all objects of a specific color"""
        color_key = f"{color.lower()}_objects"
        return self.database.get("objects", {}).get(color_key, [])
    
    def get_all_objects(self) -> Dict[str, List[Dict]]:
        """Get all objects organized by color"""
        return self.database.get("objects", {})
    
    def get_total_object_count(self) -> int:
        """Count total objects across all colors"""
        total = 0
        for color_objects in self.database.get("objects", {}).values():
            total += len(color_objects)
        return total
    
    def get_database_statistics(self) -> Dict:
        """Generate comprehensive database statistics"""
        stats = {
            "total_objects": self.get_total_object_count(),
            "objects_by_color": {},
            "average_confidence": 0,
            "most_reliable_objects": [],
            "least_reliable_objects": [],
            "database_health": "Good"
        }
        
        all_confidences = []
        all_objects_with_stats = []
        
        # Analyze by color
        for color_key, objects in self.database.get("objects", {}).items():
            color = color_key.replace("_objects", "")
            stats["objects_by_color"][color] = {
                "count": len(objects),
                "avg_confidence": 0,
                "total_successes": 0,
                "total_failures": 0
            }
            
            if objects:
                confidences = [obj["confidence"] for obj in objects]
                stats["objects_by_color"][color]["avg_confidence"] = sum(confidences) / len(confidences)
                stats["objects_by_color"][color]["total_successes"] = sum(obj["success_count"] for obj in objects)
                stats["objects_by_color"][color]["total_failures"] = sum(obj["failure_count"] for obj in objects)
                
                all_confidences.extend(confidences)
                
                # Track objects for reliability ranking
                for obj in objects:
                    total_attempts = obj["success_count"] + obj["failure_count"]
                    success_rate = obj["success_count"] / total_attempts if total_attempts > 0 else 0
                    all_objects_with_stats.append({
                        "name": obj["object_name"],
                        "color": color,
                        "success_rate": success_rate,
                        "confidence": obj["confidence"],
                        "total_attempts": total_attempts
                    })
        
        # Overall statistics
        if all_confidences:
            stats["average_confidence"] = sum(all_confidences) / len(all_confidences)
        
        # Reliability rankings (only objects with at least 3 attempts)
        reliable_objects = [obj for obj in all_objects_with_stats if obj["total_attempts"] >= 3]
        reliable_objects.sort(key=lambda x: x["success_rate"], reverse=True)
        
        stats["most_reliable_objects"] = reliable_objects[:5]
        stats["least_reliable_objects"] = reliable_objects[-5:] if len(reliable_objects) > 5 else []
        
        # Database health assessment
        if stats["average_confidence"] < 0.6:
            stats["database_health"] = "Poor - Low confidence scores"
        elif stats["total_objects"] < 3:
            stats["database_health"] = "Warning - Few objects tracked"
        
        return stats
    
    def print_database_report(self):
        """Print a comprehensive database report"""
        stats = self.get_database_statistics()
        
        print("\n" + "="*60)
        print("📊 CORI DATABASE ANALYTICS REPORT")
        print("="*60)
        
        print(f"\n📈 OVERVIEW:")
        print(f"   Total Objects: {stats['total_objects']}")
        print(f"   Average Confidence: {stats['average_confidence']:.2f}")
        print(f"   Database Health: {stats['database_health']}")
        
        print(f"\n🎨 OBJECTS BY COLOR:")
        for color, data in stats['objects_by_color'].items():
            if data['count'] > 0:
                success_rate = data['total_successes'] / (data['total_successes'] + data['total_failures']) if (data['total_successes'] + data['total_failures']) > 0 else 0
                print(f"   {color.title()}: {data['count']} objects, "
                      f"avg confidence: {data['avg_confidence']:.2f}, "
                      f"success rate: {success_rate:.1%}")
        
        if stats['most_reliable_objects']:
            print(f"\n🏆 MOST RELIABLE OBJECTS:")
            for obj in stats['most_reliable_objects']:
                print(f"   {obj['name']} ({obj['color']}): {obj['success_rate']:.1%} success rate")
        
        if stats['least_reliable_objects']:
            print(f"\n⚠️  OBJECTS NEEDING ATTENTION:")
            for obj in stats['least_reliable_objects']:
                print(f"   {obj['name']} ({obj['color']}): {obj['success_rate']:.1%} success rate")
        
        print("\n" + "="*60)

def main():
    """Interactive database management interface"""
    db_manager = CORIDatabaseManager()
    
    while True:
        print("\n" + "="*50)
        print("🗄️  CORI DATABASE MANAGER")
        print("="*50)
        print("1. View database report")
        print("2. Add new object")
        print("3. Remove object") 
        print("4. List objects by color")
        print("5. Update object statistics")
        print("6. Create database backup")
        print("7. Exit")
        
        choice = input("\nSelect option (1-7): ").strip()
        
        if choice == "1":
            db_manager.print_database_report()
            
        elif choice == "2":
            color = input("Object color: ").strip().lower()
            name = input("Object name: ").strip()
            try:
                x = float(input("X coordinate (meters): "))
                y = float(input("Y coordinate (meters): "))
                confidence = float(input("Initial confidence (0.0-1.0, default 0.8): ") or "0.8")
                notes = input("Notes (optional): ").strip()
                
                db_manager.add_new_object(color, name, x, y, confidence, notes)
            except ValueError:
                print("❌ Invalid input. Please enter numeric values for coordinates.")
                
        elif choice == "3":
            color = input("Object color: ").strip().lower()
            name = input("Object name: ").strip()
            db_manager.remove_object(color, name)
            
        elif choice == "4":
            color = input("Color to list: ").strip().lower()
            objects = db_manager.get_objects_by_color(color)
            if objects:
                print(f"\n{color.title()} objects:")
                for obj in objects:
                    print(f"  • {obj['object_name']} at {obj['primary_location']:.1f}° "
                          f"(confidence: {obj['confidence']:.2f})")
            else:
                print(f"No {color} objects found")
                
        elif choice == "5":
            color = input("Object color: ").strip().lower()
            name = input("Object name: ").strip()
            success = input("Was last detection successful? (y/n): ").strip().lower() == 'y'
            db_manager.update_object_success_rate(color, name, success)
            
        elif choice == "6":
            db_manager._create_backup()
            
        elif choice == "7":
            print("👋 Goodbye!")
            break
            
        else:
            print("❌ Invalid option. Please try again.")

if __name__ == "__main__":
    main()

=== ./src/cori_cv/cori_cv/color_display.py ===
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import os

class ColorDisplay(Node):
    def __init__(self):
        super().__init__('color_display')
        
        # Subscribe to color detection
        self.subscription = self.create_subscription(
            String,
            '/cori/color_detected',
            self.color_callback,
            10
        )
        
        self.get_logger().info('Color Display Ready - Listening for colors...')
        self.print_header()

    def print_header(self):
        """Print a nice header"""
        os.system('clear')  # Clear terminal
        print("=" * 60)
        print("CORI ROBOT COLOR DETECTION SYSTEM")
        print("=" * 60)
        print("Looking at the world through CORI's camera...")
        print()

    def color_callback(self, msg):
        """Display detected color with fancy formatting"""
        color = msg.data
        
        # Color mappings for terminal colors
        color_codes = {
            'RED': '\033[91m',
            'GREEN': '\033[92m', 
            'YELLOW': '\033[93m',
            'BLUE': '\033[94m',
            'PURPLE': '\033[95m',
            'CYAN': '\033[96m',
            'WHITE': '\033[97m',
            'BLACK': '\033[90m',
            'GRAY': '\033[37m',
            'ORANGE': '\033[33m'
        }
        
        # Get pile classification
        pile = self.classify_pile(color)
        
        # Color code for display
        color_code = color_codes.get(color, '\033[0m')
        reset_code = '\033[0m'
        
        # Clear and redraw
        self.print_header()
        
        print(f"CURRENT DETECTION:")
        print(f"   Color: {color_code}{color}{reset_code}")
        print(f"   Pile:  {pile.upper()}")
        print()
        print("Hold different colored objects in front of CORI's camera!")
        print("Press Ctrl+C to stop")

    def classify_pile(self, color_name):
        """Classify color into laundry piles"""
        if color_name in ['WHITE', 'YELLOW']:
            return 'lights'
        elif color_name in ['BLACK', 'GRAY', 'PURPLE']:
            return 'darks'
        elif color_name in ['RED', 'ORANGE', 'GREEN', 'BLUE', 'CYAN']:
            return 'colors'
        return 'unknown'

def main():
    rclpy.init()
    node = ColorDisplay()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\nGoodbye!")
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()

=== ./src/cori_cv/cori_cv/object_detection.py ===
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64
import math
import time

class ObjectDetection(Node):
    def __init__(self):
        super().__init__('object_detection')
        
        # Publishers for CORI's ONLY movable joint: head_joint
        self.head_pub = self.create_publisher(Float64, '/model/cori/joint/head_joint/cmd_pos', 10)
        
        # Alternative topic formats to try
        self.head_pub2 = self.create_publisher(Float64, '/cori/head_joint/cmd_pos', 10)
        self.head_pub3 = self.create_publisher(Float64, '/head_joint/cmd_pos', 10)
        self.head_pub4 = self.create_publisher(Float64, '/joint_states/head_joint', 10)
        
        # Simple movement variables
        self.time_start = time.time()
        
        # Timer for smooth movement
        self.timer = self.create_timer(0.1, self.move_head)  # 10 Hz
        
        self.get_logger().info("🎯 Object Detection Ready!")
        self.get_logger().info("🔍 CORI scanning for objects - head moving left/right and up/down")
        self.get_logger().info("⏰ Pattern: 4 seconds left/right, 4 seconds up/down")
        
    def move_head(self):
        """Simple head movement pattern"""
        current_time = time.time() - self.time_start
        cycle_time = current_time % 8.0  # 8 second cycle
        
        if cycle_time < 4.0:
            # First 4 seconds: Rotate head left and right (Z-axis rotation)
            head_angle = math.sin(cycle_time * math.pi / 2) * 3.0  # -3.0 to +3.0 radians (HUGE!)
        else:
            # Next 4 seconds: Different rotation pattern
            head_angle = math.sin((cycle_time - 4.0) * math.pi / 1) * 2.0  # Faster oscillation
        
        # Create message for the single head joint
        head_msg = Float64()
        head_msg.data = head_angle
        
        # Publish to all possible topics for head_joint
        self.head_pub.publish(head_msg)
        self.head_pub2.publish(head_msg)
        self.head_pub3.publish(head_msg)
        self.head_pub4.publish(head_msg)
        
        # Log current position every half second for more feedback
        if int(current_time * 2) % 1 == 0 and int(current_time * 20) % 10 == 0:
            if cycle_time < 4.0:
                self.get_logger().info(f"🔍 HEAD_JOINT ROTATION - Angle: {head_angle:.2f} (±3.0 rad)")
            else:
                self.get_logger().info(f"🔍 HEAD_JOINT FAST SCAN - Angle: {head_angle:.2f} (±2.0 rad)")

def main(args=None):
    rclpy.init(args=args)
    mover = ObjectDetection()
    
    try:
        rclpy.spin(mover)
    except KeyboardInterrupt:
        print("\n🛑 Stopping Object Detection...")
    finally:
        mover.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()

=== ./src/cori_cv/cori_cv/sensor_fusion/sensor_fusion_demo.py ===
#!/usr/bin/env python3
"""
CORI Sensor Fusion Demo with Physics Wake-up Fix
Combines camera detection with spatial database for intelligent head movement
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import String, Float64
from cv_bridge import CvBridge
import cv2
import numpy as np
import time
import math
import sys
import os

# Add the sensor_fusion directory to Python path
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(current_dir)

from spatial_database import SpatialDatabase

class SensorFusionDemo(Node):
    def __init__(self):
        super().__init__('sensor_fusion_demo')
        
        # Initialize components
        self.bridge = CvBridge()
        self.spatial_db = SpatialDatabase()
        
        # Physics tracking
        self.physics_awakened = False
        self.last_movement_time = 0
        self.current_head_angle = 0.0
        
        # Detection parameters
        self.detection_threshold = 3  # Need 3 consistent detections
        self.current_detections = []
        self.last_color = "unknown"
        self.detection_confidence = 0
        
        # Color thresholds (BGR format for OpenCV)
        self.color_ranges = {
            'red': {
                'lower1': np.array([0, 50, 50]),     # Lower red range
                'upper1': np.array([10, 255, 255]),
                'lower2': np.array([170, 50, 50]),   # Upper red range  
                'upper2': np.array([180, 255, 255])
            },
            'blue': {
                'lower': np.array([100, 50, 50]),
                'upper': np.array([130, 255, 255])
            },
            'green': {
                'lower': np.array([40, 50, 50]),
                'upper': np.array([80, 255, 255])
            },
            'white': {
                'lower': np.array([0, 0, 200]),
                'upper': np.array([180, 30, 255])
            }
        }
        
        # Set up subscribers and publishers
        self.setup_ros_connections()
        
        # Wake up physics system
        self.get_logger().info("🤖 Initializing sensor fusion demo...")
        self.wake_up_physics()
        
        self.get_logger().info("🧠 Sensor fusion demo ready!")
        self.get_logger().info("📷 Hold colored objects in front of camera:")
        self.get_logger().info("   🔴 RED → Head turns LEFT")
        self.get_logger().info("   🔵 BLUE → Head turns RIGHT") 
        self.get_logger().info("   🟢 GREEN → Head looks STRAIGHT")
        
    def setup_ros_connections(self):
        """Set up ROS subscribers and publishers"""
        
        # Try multiple camera topic possibilities
        camera_topics = [
            '/camera/image_raw',
            '/image_raw', 
            '/camera/color/image_raw',
            '/usb_cam/image_raw'
        ]
        
        # Find which camera topic exists
        available_topics = self.get_topic_names_and_types()
        available_topic_names = [topic[0] for topic in available_topics]
        
        camera_topic = None
        for topic in camera_topics:
            if topic in available_topic_names:
                camera_topic = topic
                break
                
        if camera_topic:
            self.get_logger().info(f"📷 Found camera topic: {camera_topic}")
            self.camera_subscriber = self.create_subscription(
                Image,
                camera_topic,
                self.camera_callback,
                10
            )
        else:
            self.get_logger().warn("📷 No camera topic found! Available topics:")
            for topic in available_topic_names:
                if 'image' in topic or 'camera' in topic:
                    self.get_logger().warn(f"   {topic}")
            
            # Default to most common one
            self.camera_subscriber = self.create_subscription(
                Image,
                '/image_raw',
                self.camera_callback,
                10
            )
        
        # Color detection publisher
        self.color_publisher = self.create_publisher(
            String,
            '/cori/color_detected',
            10
        )
        
        # Head joint controller
        self.joint_publisher = self.create_publisher(
            Float64,
            '/model/cori/joint/head_joint/cmd_pos',
            10
        )
        
        # Status publisher  
        self.status_publisher = self.create_publisher(
            String,
            '/cori/sensor_fusion_status',
            10
        )

    def wake_up_physics(self):
        """Wake up Gazebo physics by sending small movements to joints"""
        self.get_logger().info("🔌 Waking up Gazebo physics...")
        
        # Wait for publishers to be ready
        time.sleep(1.0)
        
        # Send small movements to activate physics
        wake_up_sequence = [0.01, -0.01, 0.005, -0.005, 0.0]
        
        for angle in wake_up_sequence:
            msg = Float64()
            msg.data = angle
            self.joint_publisher.publish(msg)
            time.sleep(0.2)
            
        self.physics_awakened = True
        self.current_head_angle = 0.0
        self.get_logger().info("✅ Physics awakened - joints should now respond smoothly")

    def detect_object_color(self, cv_image):
        """Detect dominant color in image using HSV color space"""
        
        # Convert BGR to HSV for better color detection
        hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)
        
        # Get image center region (focus on what's being held up)
        height, width = hsv.shape[:2]
        center_x, center_y = width // 2, height // 2
        roi_size = min(width, height) // 4
        
        roi = hsv[
            center_y - roi_size:center_y + roi_size,
            center_x - roi_size:center_x + roi_size
        ]
        
        # Check each color
        color_scores = {}
        
        # Red (special case - needs two ranges)
        if 'red' in self.color_ranges:
            mask1 = cv2.inRange(roi, self.color_ranges['red']['lower1'], self.color_ranges['red']['upper1'])
            mask2 = cv2.inRange(roi, self.color_ranges['red']['lower2'], self.color_ranges['red']['upper2']) 
            red_mask = cv2.bitwise_or(mask1, mask2)
            color_scores['red'] = np.sum(red_mask) / 255
            
        # Other colors
        for color_name, ranges in self.color_ranges.items():
            if color_name == 'red':
                continue
                
            mask = cv2.inRange(roi, ranges['lower'], ranges['upper'])
            color_scores[color_name] = np.sum(mask) / 255
        
        # Find dominant color
        if color_scores:
            dominant_color = max(color_scores, key=color_scores.get)
            max_score = color_scores[dominant_color]
            
            # Threshold for detection confidence
            if max_score > 500:  # Adjust this threshold as needed
                return dominant_color
                
        return "unknown"

    def camera_callback(self, msg):
        """Process camera images for color detection"""
        try:
            # Convert ROS image to OpenCV
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
            
            # Detect color
            detected_color = self.detect_object_color(cv_image)
            
            # Add debug output
            if detected_color != "unknown":
                self.get_logger().info(f"🎨 DETECTED COLOR: {detected_color.upper()}")
            
            # Require consistent detections
            self.current_detections.append(detected_color)
            if len(self.current_detections) > self.detection_threshold:
                self.current_detections.pop(0)
            
            # Check for stable detection
            if len(self.current_detections) >= self.detection_threshold:
                unique_colors = set(self.current_detections)
                if len(unique_colors) == 1 and detected_color != "unknown":
                    stable_color = detected_color
                    
                    # Only process if it's a new color
                    if stable_color != self.last_color:
                        self.process_color_detection(stable_color)
                        self.last_color = stable_color
                        
                elif detected_color == "unknown":
                    # Reset if no color detected
                    if self.last_color != "unknown":
                        self.last_color = "unknown"
                        self.publish_status("🔍 Scanning for objects...")
                        
        except Exception as e:
            self.get_logger().error(f"Camera callback error: {e}")

    def process_color_detection(self, color):
        """Process detected color with spatial database"""
        
        self.get_logger().info(f"🎯 Physical sensor detects {color.upper()}")
        
        # Publish color detection
        color_msg = String()
        color_msg.data = color
        self.color_publisher.publish(color_msg)
        
        # Query spatial database
        location_data = self.spatial_db.query_object_location(color)
        
        if location_data:
            angle = location_data['angle']
            confidence = location_data['confidence']
            
            self.get_logger().info(f"🗃️  Environmental database: {color.upper()} typically at {angle}° (confidence: {confidence:.2f})")
            
            # Move head to predicted location
            self.move_head_to_angle(angle)
            
            # Update database with successful detection
            self.spatial_db.update_object_success(color, angle)
            
            self.publish_status(f"🎯 Target acquired: {color.upper()} at {angle}°")
            
        else:
            self.get_logger().info(f"❓ No spatial data for {color.upper()}")
            self.publish_status(f"🔍 Learning new object: {color.upper()}")

    def move_head_to_angle(self, angle_degrees):
        """Move CORI's head to specified angle with physics wake-up if needed"""
        
        # Check if physics needs wake-up (if it's been a while since last movement)
        current_time = time.time()
        if not self.physics_awakened or (current_time - self.last_movement_time) > 10:
            self.get_logger().info("🔌 Physics may be sleeping, sending wake-up sequence...")
            self.wake_up_physics()
        
        # Convert degrees to radians with scaling for visible movement
        # Make movements more dramatic for demo purposes
        angle_rad = math.radians(angle_degrees * 0.03)  # Scale down for safety
        
        self.get_logger().info(f"🤖 Moving head to {angle_degrees}° ({angle_rad:.3f} rad)")
        
        # Send movement command
        msg = Float64()
        msg.data = angle_rad
        self.joint_publisher.publish(msg)
        
        # Update tracking
        self.current_head_angle = angle_rad
        self.last_movement_time = current_time
        
        # Publish status
        direction = "LEFT" if angle_degrees > 0 else "RIGHT" if angle_degrees < 0 else "CENTER"
        self.publish_status(f"🤖 Head moving {direction} ({angle_degrees}°)")

    def publish_status(self, message):
        """Publish status message"""
        status_msg = String()
        status_msg.data = message
        self.status_publisher.publish(status_msg)

def main(args=None):
    rclpy.init(args=args)
    
    try:
        sensor_fusion_demo = SensorFusionDemo()
        rclpy.spin(sensor_fusion_demo)
        
    except KeyboardInterrupt:
        print("\n🛑 Sensor fusion demo stopped by user")
        
    except Exception as e:
        print(f"❌ Error in sensor fusion demo: {e}")
        
    finally:
        if rclpy.ok():
            rclpy.shutdown()

if __name__ == '__main__':
    main()
=== ./src/cori_cv/cori_cv/sensor_fusion/demo_display.py ===
#!/usr/bin/env python3
"""
CORI Sensor Fusion Demo Display
Clean terminal interface showing sensor fusion progress
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import os
import time
from datetime import datetime

class DemoDisplay(Node):
    def __init__(self):
        super().__init__('demo_display')
        
        # Subscribe to demo status
        self.status_sub = self.create_subscription(
            String, '/cori/demo_status', self.status_callback, 10)
        
        # Subscribe to color detection
        self.color_sub = self.create_subscription(
            String, '/cori/color_detected', self.color_callback, 10)
        
        # Display state
        self.current_status = "System initializing..."
        self.current_color = "NONE"
        self.status_history = []
        self.demo_start_time = time.time()
        
        # Display timer
        self.display_timer = self.create_timer(0.5, self.update_display)
        
        self.get_logger().info("Demo display ready")
        self.clear_screen()
    
    def status_callback(self, msg):
        """Handle status updates"""
        self.current_status = msg.data
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        self.status_history.append(f"[{timestamp}] {msg.data}")
        
        # Keep only last 8 status messages
        if len(self.status_history) > 8:
            self.status_history.pop(0)
    
    def color_callback(self, msg):
        """Handle color detection updates"""
        self.current_color = msg.data
    
    def clear_screen(self):
        """Clear terminal screen"""
        os.system('clear' if os.name == 'posix' else 'cls')
    
    def get_colored_text(self, color):
        """Return colored text for terminal display"""
        color_codes = {
            'RED': '\033[91m',
            'GREEN': '\033[92m',
            'YELLOW': '\033[93m',
            'BLUE': '\033[94m',
            'PURPLE': '\033[95m',
            'CYAN': '\033[96m',
            'WHITE': '\033[97m',
            'BLACK': '\033[90m',
            'GRAY': '\033[37m',
            'ORANGE': '\033[33m',
            'NONE': '\033[37m'
        }
        
        reset = '\033[0m'
        color_code = color_codes.get(color, '\033[0m')
        
        return f"{color_code}{color}{reset}"
    
    def update_display(self):
        """Update the display"""
        self.clear_screen()
        
        # Calculate runtime
        runtime = time.time() - self.demo_start_time
        runtime_str = f"{int(runtime//60):02d}:{int(runtime%60):02d}"
        
        # Header
        print("=" * 80)
        print("🤖 CORI SENSOR FUSION DEMONSTRATION")
        print("   Combining Real-Time Detection with Spatial Memory")
        print("=" * 80)
        print()
        
        # Current status
        print("📊 CURRENT STATUS")
        print("-" * 40)
        print(f"   Detected Object: {self.get_colored_text(self.current_color)}")
        print(f"   System State:    {self.current_status}")
        print(f"   Runtime:         {runtime_str}")
        print()
        
        # System architecture
        print("🏗️  SYSTEM ARCHITECTURE")
        print("-" * 40)
        print("   Physical Camera → OpenCV Detection → ROS 2 Messages")
        print("                           ↓")
        print("   Spatial Database ← Learning System ← Head Movement")
        print("                           ↓")
        print("   Professional Robotics: Sensor Fusion in Action")
        print()
        
        # Expected behavior
        print("🎯 EXPECTED BEHAVIOR")
        print("-" * 40)
        print("   🔴 Hold RED object   → CORI looks LEFT (~14°)")
        print("   🔵 Hold BLUE object  → CORI looks RIGHT (~-16°)")
        print("   🟢 Hold GREEN object → CORI looks STRAIGHT (0°)")
        print("   ⚪ Hold WHITE object → CORI looks slightly LEFT (~5°)")
        print()
        
        # Demo instructions
        print("📋 DEMO INSTRUCTIONS")
        print("-" * 40)
        print("   1. Hold colored objects steadily in front of camera")
        print("   2. Wait for 'Physical sensor detects [COLOR]'")
        print("   3. Watch CORI's head move to predicted location")
        print("   4. Observe learning: confidence increases over time")
        print("   5. Press Ctrl+C to stop demo")
        print()
        
        # Live status history
        print("📡 LIVE STATUS FEED")
        print("-" * 40)
        if self.status_history:
            for status in self.status_history[-6:]:  # Show last 6 messages
                print(f"   {status}")
        else:
            print("   Waiting for sensor fusion events...")
        print()
        
        # Demo results for Dan
        print("🎓 WHY THIS MATTERS FOR PRODUCTION ROBOTICS")
        print("-" * 40)
        print("   ✅ Real-time sensor data fusion")
        print("   ✅ Spatial memory and prediction")
        print("   ✅ Adaptive learning algorithms")
        print("   ✅ Professional ROS 2 architecture")
        print("   ✅ Scalable to multiple sensors/objects")
        print()
        print("   This is exactly how warehouse robots and autonomous")
        print("   vehicles combine multiple data sources for intelligent")
        print("   decision making! 🚗 🤖")
        print()
        
        # Footer
        print("=" * 80)
        print("CORI Sensor Fusion Demo - Press Ctrl+C to exit")
        print("=" * 80)


def main():
    rclpy.init()
    display = DemoDisplay()
    
    try:
        rclpy.spin(display)
    except KeyboardInterrupt:
        display.get_logger().info("Demo display shutdown")
    finally:
        display.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
=== ./src/cori_cv/cori_cv/sensor_fusion/spatial_database.py ===
#!/usr/bin/env python3
"""
CORI Spatial Object Database
Maps virtual laundry objects to angular positions for sensor fusion demo
"""

import json
import math
import time
import os
from typing import Dict, List, Tuple, Optional

class SpatialObjectDatabase:
    """
    Database that tracks object locations in angular coordinates relative to CORI's head
    Based on the actual positions in laundry_world.sdf
    """
    
    def __init__(self, db_file: str = "database/cori_spatial_database.json"):
        self.db_file = db_file
        self.objects = {}
        self.initialize_from_world_data()
        self.load_or_create_database()
    
    def initialize_from_world_data(self):
        """Initialize database from actual world object positions"""
        # CORI's position in world (assumed at origin facing +X)
        cori_position = (0.0, 0.0)  # x, y in world coordinates
        cori_facing = 0.0  # facing +X direction (0 degrees)
        
        # Object positions from laundry_world.sdf
        world_objects = {
            # Laundry items on table
            "shirt_green": {"position": (1.0, 0.0), "color": "green"},
            "sock_white": {"position": (1.2, 0.1), "color": "white"},  
            "sock_dark": {"position": (1.1, -0.1), "color": "black"},
            "shirt_red": {"position": (0.8, 0.2), "color": "red"},
            "pants_blue": {"position": (0.7, -0.2), "color": "blue"},
            "towel_gray": {"position": (1.3, -0.2), "color": "gray"},
            
            # Laundry bins (for reference)
            "bin_darks": {"position": (2.0, 0.5), "color": "black"},
            "bin_colors": {"position": (2.0, 0.0), "color": "orange"},
            "bin_lights": {"position": (2.0, -0.5), "color": "white"},
        }
        
        # Convert world positions to angular positions
        for obj_name, obj_data in world_objects.items():
            obj_x, obj_y = obj_data["position"]
            color = obj_data["color"]
            
            # Calculate angle from CORI's position to object
            dx = obj_x - cori_position[0]
            dy = obj_y - cori_position[1]
            
            # Calculate angle in degrees (0° = straight ahead, +90° = left, -90° = right)
            angle_rad = math.atan2(dy, dx)
            angle_deg = math.degrees(angle_rad)
            
            # Calculate distance for confidence scoring
            distance = math.sqrt(dx*dx + dy*dy)
            
            # Generate confidence based on "experience" (closer objects = higher confidence)
            base_confidence = max(0.3, min(0.95, 1.0 - (distance - 0.5) * 0.2))
            
            # Add some realistic variation in success/failure counts
            success_count = max(1, int(10 * base_confidence))
            failure_count = max(0, int(10 * (1 - base_confidence)))
            
            # Store in database format
            color_key = f"{color}_objects"
            if color_key not in self.objects:
                self.objects[color_key] = []
            
            self.objects[color_key].append({
                "object_name": obj_name,
                "primary_location": round(angle_deg, 1),
                "distance": round(distance, 2),
                "confidence": round(base_confidence, 2),
                "last_seen": time.time(),
                "search_radius": round(max(10.0, 30.0 * (1 - base_confidence)), 1),
                "success_count": success_count,
                "failure_count": failure_count,
                "world_position": {"x": obj_x, "y": obj_y},
                "notes": f"Initialized from world position at ({obj_x}, {obj_y})"
            })
    
    def load_or_create_database(self):
        """Load existing database or create new one"""
        if os.path.exists(self.db_file):
            try:
                with open(self.db_file, 'r') as f:
                    loaded_data = json.load(f)
                    
                # Merge with world data (world data takes precedence for positions)
                for color_key, objects in self.objects.items():
                    if color_key in loaded_data:
                        # Keep learning data but update positions
                        for obj in objects:
                            loaded_obj = self.find_object_in_loaded_data(
                                loaded_data[color_key], obj["object_name"]
                            )
                            if loaded_obj:
                                # Keep learning stats but update position
                                obj["confidence"] = loaded_obj.get("confidence", obj["confidence"])
                                obj["success_count"] = loaded_obj.get("success_count", obj["success_count"])
                                obj["failure_count"] = loaded_obj.get("failure_count", obj["failure_count"])
                                obj["last_seen"] = loaded_obj.get("last_seen", obj["last_seen"])
                
                print(f"✅ Loaded existing database and merged with world data")
                
            except Exception as e:
                print(f"⚠️  Error loading database: {e}")
                print("📝 Creating new database from world data")
        
        self.save_database()
        self.print_database_summary()
    
    def find_object_in_loaded_data(self, loaded_objects: List, object_name: str) -> Optional[Dict]:
        """Find object in loaded data by name"""
        for obj in loaded_objects:
            if obj.get("object_name") == object_name:
                return obj
        return None
    
    def save_database(self):
        """Save database to JSON file"""
        try:
            # Add metadata
            database_with_metadata = {
                "metadata": {
                    "created": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "description": "CORI Spatial Object Database - Maps virtual objects to angular positions",
                    "coordinate_system": "Degrees from CORI center (0° = straight ahead, +° = left, -° = right)",
                    "total_objects": sum(len(objs) for objs in self.objects.values())
                },
                "objects": self.objects
            }
            
            with open(self.db_file, 'w') as f:
                json.dump(database_with_metadata, f, indent=2)
            print(f"💾 Database saved to {self.db_file}")
            
        except Exception as e:
            print(f"❌ Error saving database: {e}")
    
    def print_database_summary(self):
        """Print a nice summary of the database"""
        print("\n" + "="*80)
        print("🗃️  CORI SPATIAL OBJECT DATABASE")
        print("="*80)
        
        total_objects = 0
        for color_key, objects in self.objects.items():
            color_name = color_key.replace("_objects", "").upper()
            print(f"\n📍 {color_name} OBJECTS:")
            print("-" * 40)
            
            for obj in objects:
                total_objects += 1
                angle = obj["primary_location"]
                confidence = obj["confidence"]
                distance = obj["distance"]
                success_rate = obj["success_count"] / (obj["success_count"] + obj["failure_count"])
                
                # Direction indicator
                if angle > 15:
                    direction = "⬅️  LEFT"
                elif angle < -15:
                    direction = "➡️  RIGHT"
                else:
                    direction = "⬆️  STRAIGHT"
                
                print(f"   {obj['object_name']:<15} → {angle:>6.1f}° {direction}")
                print(f"   {'':15}   Distance: {distance:.1f}m, Confidence: {confidence:.2f}, Success: {success_rate:.1%}")
        
        print(f"\n📊 SUMMARY: {total_objects} objects tracked across {len(self.objects)} color categories")
        print("="*80 + "\n")
    
    def get_predicted_location(self, color: str) -> Optional[Dict]:
        """Get predicted location for a color (mimics the demo interface)"""
        color_key = f"{color.lower()}_objects"
        if color_key in self.objects and self.objects[color_key]:
            # Return the most confident object of this color
            best_obj = max(self.objects[color_key], key=lambda x: x["confidence"])
            return {
                'location': best_obj['primary_location'],
                'confidence': best_obj['confidence'], 
                'search_radius': best_obj['search_radius'],
                'object_name': best_obj['object_name'],
                'distance': best_obj['distance']
            }
        return None
    
    def update_success(self, color: str, found_location: float):
        """Update database when object found (mimics the demo interface)"""
        color_key = f"{color.lower()}_objects"
        if color_key in self.objects and self.objects[color_key]:
            # Find closest object to the found location
            best_match = min(
                self.objects[color_key], 
                key=lambda x: abs(x["primary_location"] - found_location)
            )
            
            best_match["success_count"] += 1
            best_match["last_seen"] = time.time()
            
            # Update confidence
            total_attempts = best_match["success_count"] + best_match["failure_count"]
            best_match["confidence"] = min(0.95, best_match["success_count"] / total_attempts)
            
            # Update search radius
            best_match["search_radius"] = max(5.0, 30.0 * (1 - best_match["confidence"]))
            
            self.save_database()
            print(f"✅ Updated {best_match['object_name']}: confidence now {best_match['confidence']:.2f}")
    
    def update_failure(self, color: str):
        """Update database when object not found"""
        color_key = f"{color.lower()}_objects"
        if color_key in self.objects and self.objects[color_key]:
            # Update the most confident object of this color
            best_obj = max(self.objects[color_key], key=lambda x: x["confidence"])
            
            best_obj["failure_count"] += 1
            
            # Update confidence
            total_attempts = best_obj["success_count"] + best_obj["failure_count"]
            best_obj["confidence"] = best_obj["success_count"] / total_attempts
            
            # Increase search radius
            best_obj["search_radius"] = min(60.0, best_obj["search_radius"] * 1.2)
            
            self.save_database()
            print(f"⚠️  Updated {best_obj['object_name']}: confidence now {best_obj['confidence']:.2f}")
    
    def list_objects_by_confidence(self) -> List[Tuple[str, float, float]]:
        """Return list of (object_name, angle, confidence) sorted by confidence"""
        all_objects = []
        for color_key, objects in self.objects.items():
            for obj in objects:
                all_objects.append((
                    obj["object_name"],
                    obj["primary_location"], 
                    obj["confidence"]
                ))
        
        return sorted(all_objects, key=lambda x: x[2], reverse=True)
    
    def get_demo_script(self) -> List[str]:
        """Generate demo script showing best objects to test"""
        demo_objects = self.list_objects_by_confidence()[:5]  # Top 5 most confident
        
        script = [
            "🎯 RECOMMENDED DEMO SEQUENCE:",
            "Hold colored objects in front of camera in this order for best results:",
            ""
        ]
        
        for i, (obj_name, angle, confidence) in enumerate(demo_objects, 1):
            color = obj_name.split('_')[1] if '_' in obj_name else obj_name
            direction = "LEFT" if angle > 15 else "RIGHT" if angle < -15 else "STRAIGHT"
            script.append(f"{i}. {color.upper()} object → CORI will look {direction} ({angle:+.1f}°) [confidence: {confidence:.1%}]")
        
        return script


def main():
    """Demo the database creation and usage"""
    print("🚀 Initializing CORI Spatial Object Database...")
    
    # Create database
    db = SpatialObjectDatabase()
    
    # Show demo script
    print("\n".join(db.get_demo_script()))
    
    # Test the interface that the sensor fusion demo will use
    print(f"\n🧪 TESTING DEMO INTERFACE:")
    print("-" * 40)
    
    test_colors = ["red", "green", "white", "blue"]
    for color in test_colors:
        result = db.get_predicted_location(color)
        if result:
            print(f"🔍 {color.upper()} → {result['location']:+.1f}° (confidence: {result['confidence']:.1%}, object: {result['object_name']})")
        else:
            print(f"❌ {color.upper()} → No objects found")
    
    print(f"\n✅ Database ready for sensor fusion demo!")
    print(f"📁 Saved to: {db.db_file}")


if __name__ == "__main__":
    main()
=== ./src/cori_cv/package.xml ===
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypelevel="warn"?>
<package format="3">
  <name>cori_cv</name>
  <version>0.0.0</version>
  <description>CORI Computer Vision Package</description>
  <maintainer email="jwuptegraph@gmail.com">Johnathan Uptegraph</maintainer>
  <license>Apache License 2.0</license>

  <depend>rclpy</depend>
  <depend>sensor_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>std_msgs</depend>
  <depend>cv_bridge</depend>
  <depend>opencv2</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
=== ./src/cori_cv/launch/laundry_color_detector.launch.py ===
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='v4l2_camera',
            executable='v4l2_camera_node',
            name='camera',
            parameters=[{
                'video_device': '/dev/video0',
                'image_size': [800, 600],
                'pixel_format': 'YUYV',
                'camera_frame_id': 'camera_frame',
                'brightness': 128,
                'contrast': 200,
                'saturation': 180,
                'sharpness': 255
            }],
            remappings=[
                ('/image_raw', '/camera/color/image_raw')
            ]
        ),
        Node(
            package='cori_cv',
            executable='laundry_color_detector',
            name='laundry_color_detector',
            output='screen',
            remappings=[
                ('/image_raw', '/camera/color/image_raw')
            ]
        )
    ])
=== ./src/cori_cv/setup.py ===
from setuptools import setup
import os
from glob import glob

package_name = 'cori_cv'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        # Add this line to include launch files
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Johnathan Uptegraph',
    maintainer_email='jwuptegraph@gmail.com',
    description='CORI Computer Vision Package',
    license='Apache License 2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'laundry_color_detector = cori_cv.laundry_color_detector:main',
            'simple_color_detector = cori_cv.simple_color_detector:main',
	        'color_display = cori_cv.color_display:main','object_detection = cori_cv.object_detection:main' 
        ],
    },
)

=== ./src/cori_cv/test/test_flake8.py ===
# Copyright 2017 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_flake8.main import main_with_errors
import pytest


@pytest.mark.flake8
@pytest.mark.linter
def test_flake8():
    rc, errors = main_with_errors(argv=[])
    assert rc == 0, \
        'Found %d code style errors / warnings:\n' % len(errors) + \
        '\n'.join(errors)

=== ./src/cori_cv/test/test_copyright.py ===
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_copyright.main import main
import pytest


# Remove the `skip` decorator once the source file(s) have a copyright header
@pytest.mark.skip(reason='No copyright header has been placed in the generated source file.')
@pytest.mark.copyright
@pytest.mark.linter
def test_copyright():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found errors'

=== ./src/cori_cv/test/test_pep257.py ===
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_pep257.main import main
import pytest


@pytest.mark.linter
@pytest.mark.pep257
def test_pep257():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found code style errors / warnings'

=== ./src/cori_spatial_database.json ===
{
  "metadata": {
    "created": "2025-06-27 11:48:28",
    "description": "CORI Spatial Object Database",
    "version": "3.0"
  },
  "objects": {},
  "laundry_data": {
    "total_items_sorted": 31,
    "hamper_counts": {
      "Lights": 4,
      "Darks": 5,
      "Colors": 22
    },
    "learning_database": {
      "red": "Colors",
      "blue": "Darks",
      "green": "Colors",
      "purple": "Colors",
      "white": "Lights"
    },
    "user_corrections": [
      {
        "color": "blue",
        "wrong_category": "Colors",
        "right_category": "Darks",
        "reason": "Because they are dark enough to ruin the colors, the blue dye is bad for the color shirts",
        "timestamp": 1751049413.4190674
      },
      {
        "color": "green",
        "wrong_category": "Colors",
        "right_category": "Lights",
        "reason": "it's light green",
        "timestamp": 1751049440.2869887
      },
      {
        "color": "blue",
        "wrong_category": "Darks",
        "right_category": "Colors",
        "reason": "it's a light blue and I don't want the dye from the jeans to ruin it",
        "timestamp": 1751049537.1747105
      },
      {
        "color": "blue",
        "wrong_category": "Colors",
        "right_category": "Darks",
        "reason": "Because it has dye in it",
        "timestamp": 1751049556.0720284
      },
      {
        "color": "green",
        "wrong_category": "Lights",
        "right_category": "Colors",
        "reason": "because its dark green",
        "timestamp": 1751049586.6859756
      }
    ],
    "confidence_level": "learning",
    "custom_colors": {},
    "sorted_items_history": [
      {
        "item_name": "Red Shirt",
        "category": "Colors",
        "timestamp": 1751039321.8368607,
        "color": "red"
      },
      {
        "item_name": "Red Shirt",
        "category": "Colors",
        "timestamp": 1751039333.004388,
        "color": "red"
      },
      {
        "item_name": "Blue Jeans",
        "category": "Darks",
        "timestamp": 1751039339.7704,
        "color": "blue"
      },
      {
        "item_name": "Blue Shirt",
        "category": "Colors",
        "timestamp": 1751039363.4822462,
        "color": "blue"
      },
      {
        "item_name": "Green Pants",
        "category": "Colors",
        "timestamp": 1751039382.1791277,
        "color": "green"
      },
      {
        "item_name": "Green Shirt",
        "category": "Colors",
        "timestamp": 1751039391.6596847,
        "color": "green"
      },
      {
        "item_name": "Purple Socks",
        "category": "Colors",
        "timestamp": 1751039400.6643307,
        "color": "purple"
      },
      {
        "item_name": "White Shirt",
        "category": "Lights",
        "timestamp": 1751039409.6303136,
        "color": "white"
      },
      {
        "item_name": "White Pants",
        "category": "Lights",
        "timestamp": 1751039414.290021,
        "color": "white"
      },
      {
        "item_name": "Red Shirt",
        "category": "Colors",
        "timestamp": 1751039429.658199,
        "color": "red"
      },
      {
        "item_name": "Green Pants",
        "category": "Colors",
        "timestamp": 1751039438.7341552,
        "color": "green"
      },
      {
        "item_name": "White Shirt",
        "category": "Lights",
        "timestamp": 1751039445.7003505,
        "color": "white"
      },
      {
        "item_name": "Green Socks",
        "category": "Colors",
        "timestamp": 1751039454.6393793,
        "color": "green"
      },
      {
        "item_name": "Blue Jeans",
        "category": "Colors",
        "timestamp": 1751039460.3551488,
        "color": "blue"
      },
      {
        "item_name": "Red Pants",
        "category": "Colors",
        "timestamp": 1751039470.4149365,
        "color": "red"
      },
      {
        "item_name": "Red Shirt",
        "category": "Colors",
        "timestamp": 1751041500.5389743,
        "color": "red"
      },
      {
        "item_name": "Green Pants",
        "category": "Colors",
        "timestamp": 1751041508.8143604,
        "color": "green"
      },
      {
        "item_name": "Red Pants",
        "category": "Colors",
        "timestamp": 1751042248.531161,
        "color": "red"
      },
      {
        "item_name": "Purple Pants",
        "category": "Colors",
        "timestamp": 1751042270.997866,
        "color": "purple"
      },
      {
        "item_name": "Green Shirt",
        "category": "Colors",
        "timestamp": 1751045386.6952455,
        "color": "green"
      },
      {
        "item_name": "Red Pants",
        "category": "Colors",
        "timestamp": 1751049368.075051,
        "color": "red"
      },
      {
        "item_name": "Purple Pants",
        "category": "Colors",
        "timestamp": 1751049387.142096,
        "color": "purple"
      },
      {
        "item_name": "Blue Jeans",
        "category": "Darks",
        "timestamp": 1751049391.8514268,
        "color": "blue"
      },
      {
        "item_name": "Red Pants",
        "category": "Colors",
        "timestamp": 1751049418.701768,
        "color": "red"
      },
      {
        "item_name": "Green Shirt",
        "category": "Lights",
        "timestamp": 1751049423.871201,
        "color": "green"
      },
      {
        "item_name": "Blue Jeans",
        "category": "Darks",
        "timestamp": 1751049507.2052245,
        "color": "blue"
      },
      {
        "item_name": "Blue Shirt",
        "category": "Colors",
        "timestamp": 1751049516.8308609,
        "color": "blue"
      },
      {
        "item_name": "Blue Jeans",
        "category": "Darks",
        "timestamp": 1751049543.0098858,
        "color": "blue"
      },
      {
        "item_name": "Blue Jeans",
        "category": "Darks",
        "timestamp": 1751049559.6432345,
        "color": "blue"
      },
      {
        "item_name": "Red Pants",
        "category": "Colors",
        "timestamp": 1751049565.9672031,
        "color": "red"
      },
      {
        "item_name": "Green Shirt",
        "category": "Colors",
        "timestamp": 1751049570.7372026,
        "color": "green"
      }
    ]
  }
}
=== ./src/cori_description/launch/display_rviz.launch.py ===
import os
from launch import LaunchDescription
from launch.substitutions import LaunchConfiguration, Command
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    pkg_share = FindPackageShare(package='cori_description').find('cori_description')
    default_urdf_model_path = os.path.join(pkg_share, 'urdf', 'cori.urdf.xacro')
    
    robot_state_publisher_node = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': Command(['xacro ', LaunchConfiguration('model', default=default_urdf_model_path)])}]
    )

    joint_state_publisher_node = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher'
    )

    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2'
    )

    return LaunchDescription([
        robot_state_publisher_node,
        joint_state_publisher_node,
        rviz_node
    ])
=== ./src/cori_description/launch/spawn_cori_ignition.launch.py ===
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os
import xacro

def generate_launch_description():
    # Paths
    package_share_dir = get_package_share_directory('cori_description')
    world_path = os.path.join(package_share_dir, 'worlds', 'laundry_world.sdf')
    xacro_file = os.path.join(package_share_dir, 'urdf', 'cori.urdf.xacro')
    
    # Validate file paths
    if not os.path.exists(world_path):
        raise FileNotFoundError(f"World file not found: {world_path}")
    if not os.path.exists(xacro_file):
        raise FileNotFoundError(f"Xacro file not found: {xacro_file}")
    
    # Process Xacro file to generate URDF
    try:
        robot_desc = xacro.process_file(xacro_file).toxml()
        print("DEBUG - Processed URDF contains:", robot_desc[:1000])  # Print first 1000 chars
    except Exception as e:
        raise RuntimeError(f"Failed to process Xacro file: {str(e)}")
    
    # Gazebo Simulation
    gz_sim = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(
                get_package_share_directory('ros_gz_sim'),
                'launch', 'gz_sim.launch.py'
            )
        ),
        launch_arguments={'gz_args': f'{world_path} -r --render-engine ogre2'}.items()
    )
    
    # Robot State Publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        output='screen',
        parameters=[{'robot_description': robot_desc, 'use_sim_time': True}]
    )
    
    # Joint State Publisher - THIS WAS MISSING!
    joint_state_publisher = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher',
        output='screen',
        parameters=[{'use_sim_time': True}]
    )
    
    # ROS-Gazebo Bridge for Joint States - THIS WAS MISSING!
    joint_state_bridge = Node(
        package='ros_gz_bridge',
        executable='parameter_bridge',
        name='joint_state_bridge',
        arguments=['/world/laundry_world/model/cori/joint_state@sensor_msgs/msg/JointState[gz.msgs.Model'],
        output='screen',
        parameters=[{'use_sim_time': True}]
    )
    
    # ROS-Gazebo Bridge for Joint Commands - THIS WAS MISSING!
    joint_cmd_bridge = Node(
        package='ros_gz_bridge',
        executable='parameter_bridge',
        name='joint_cmd_bridge',
        arguments=['/model/cori/joint/head_joint/cmd_pos@std_msgs/msg/Float64]gz.msgs.Double'],
        output='screen',
        parameters=[{'use_sim_time': True}]
    )
    
    # Spawn Robot in Gazebo
    spawn_cori = Node(
        package='ros_gz_sim',
        executable='create',
        name='spawn_cori',
        arguments=['-name', 'cori', '-topic', 'robot_description',
                '-x', '0', '-y', '0', '-z', '4', 
                '-R', '0', '-P', '0', '-Y', '1.57'],
        output='screen',
        parameters=[{'use_sim_time': True}]
    )
    
    # Launch Description
    return LaunchDescription([
        gz_sim,
        robot_state_publisher,
        joint_state_publisher,        # NEW!
        joint_state_bridge,          # NEW!
        joint_cmd_bridge,            # NEW!
        spawn_cori
    ])

if __name__ == '__main__':
    generate_launch_description()
=== ./src/cori_description/launch/spawn_cori.launch.py ===
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os

import xacro  # 🔥 Enables XACRO parsing

def generate_launch_description():
    # Package paths
    pkg_path = get_package_share_directory('cori_description')
    xacro_path = os.path.join(pkg_path, 'urdf', 'cori.urdf.xacro')

    # Use full direct path to world file to avoid install issues
    world_path = '/home/juptegraph/Workspaces/Robotics/Projects/CORI/cori_ws/src/cori_description/worlds/laundry_world.sdf'

    # Parse XACRO to generate robot_description
    robot_description_config = xacro.process_file(xacro_path)
    robot_description = robot_description_config.toxml()

    return LaunchDescription([
        # Launch Gazebo with world
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource(
                os.path.join(get_package_share_directory('gazebo_ros'), 'launch', 'gazebo.launch.py')
            ),
            launch_arguments={'world': world_path}.items()
        ),

        # State publisher
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            output='screen',
            parameters=[{'robot_description': robot_description}]
        ),

        # Joint state publisher
        Node(
            package='joint_state_publisher',
            executable='joint_state_publisher',
            name='joint_state_publisher',
            output='screen'
        ),

        # Spawn CORI in Gazebo
        Node(
            package='gazebo_ros',
            executable='spawn_entity.py',
            arguments=['-entity', 'cori', '-topic', 'robot_description'],
            output='screen'
        )
    ])

=== ./src/cori_description/worlds/laundry_world.sdf ===
<?xml version="1.0"?>
<sdf version="1.7">
  <world name="laundry_world">
    <!-- Physics with gravity -->
    <physics name="ode_physics" type="ode">
      <gravity>0 0 -9.81</gravity>
      <ode>
        <solver>
          <type>quick</type>
          <iters>50</iters>
          <sor>1.3</sor>
        </solver>
      </ode>
    </physics>

    <!-- Lighting -->
    <light type="directional" name="sun">
      <pose>0 0 10 0 0 0</pose>
      <cast_shadows>true</cast_shadows>
      <diffuse>0.9 0.9 0.9 1</diffuse>
      <specular>0.3 0.3 0.3 1</specular>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <!-- Floor -->
    <model name="carpet_floor">
      <static>true</static>
      <pose>0 0 0 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry><plane><normal>0 0 1</normal><size>100 100</size></plane></geometry>
        </collision>
        <visual name="visual">
          <geometry><plane><normal>0 0 1</normal><size>100 100</size></plane></geometry>
          <material>
            <ambient>0.4 0.4 0.4 1</ambient>
            <diffuse>0.5 0.5 0.5 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- Extended Rotated Table (3.2m long) -->
    <model name="color_table">
      <static>true</static>
      <pose>1.5 0 0.5 0 0 1.5708</pose>
      <link name="link">
        <collision name="collision">
          <geometry><box><size>3.2 0.8 0.05</size></box></geometry>
          <surface><friction><ode><mu>0.6</mu><mu2>0.6</mu2></ode></friction></surface>
        </collision>
        <visual name="visual_top">
          <geometry><box><size>3.2 0.8 0.05</size></box></geometry>
          <material>
            <ambient>0.6 0.4 0.2 1</ambient>
            <diffuse>0.7 0.5 0.3 1</diffuse>
          </material>
        </visual>
        <visual name="leg1"><pose>-1.4 -0.3733 -0.25 0 0 0</pose>
          <geometry><cylinder><radius>0.03</radius><length>0.5</length></cylinder></geometry></visual>
        <visual name="leg2"><pose>1.4 -0.3733 -0.25 0 0 0</pose>
          <geometry><cylinder><radius>0.03</radius><length>0.5</length></cylinder></geometry></visual>
        <visual name="leg3"><pose>-1.4 0.3733 -0.25 0 0 0</pose>
          <geometry><cylinder><radius>0.03</radius><length>0.5</length></cylinder></geometry></visual>
        <visual name="leg4"><pose>1.4 0.3733 -0.25 0 0 0</pose>
          <geometry><cylinder><radius>0.03</radius><length>0.5</length></cylinder></geometry></visual>
      </link>
    </model>

    <!-- Clothing Items with Gravity -->
    <model name="color_red">
      <static>false</static>
      <pose>1.5 -1.071 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>1.0 0.0 0.0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="color_orange">
      <static>false</static>
      <pose>1.5 -0.714 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>1.0 0.6 0.0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="color_yellow">
      <static>false</static>
      <pose>1.5 -0.357 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>1.0 1.0 0.0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="color_green">
      <static>false</static>
      <pose>1.5 0 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>0.0 1.0 0.0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="color_blue">
      <static>false</static>
      <pose>1.5 0.357 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>0.0 0.0 1.0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="color_purple">
      <static>false</static>
      <pose>1.5 0.714 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>0.7 0.0 1.0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="color_grey">
      <static>false</static>
      <pose>1.5 1.071 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>0.6 0.6 0.6 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="color_black">
      <static>false</static>
      <pose>1.5 1.428 0.56 0 0 0</pose>
      <link name="link">
        <gravity>true</gravity>
        <inertial><mass>0.1</mass></inertial>
        <collision name="collision">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
        </collision>
        <visual name="visual">
          <geometry><box><size>0.15 0.15 0.02</size></box></geometry>
          <material><diffuse>0.0 0.0 0.0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <!-- Original Hampers -->
    <model name="laundry_bin_darks">
      <static>true</static>
      <pose>2.5 0.5 0.0 0 0 0</pose>
      <link name="link">
        <visual name="visual">
          <geometry>
            <mesh>
              <uri>file:///home/juptegraph/Workspaces/Robotics/Projects/CORI/cori_ws/models/Laundry_Hamper.stl</uri>
              <scale>0.01 0.01 0.01</scale>
            </mesh>
          </geometry>
          <material><diffuse>0.1 0.1 0.1 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="laundry_bin_colors">
      <static>true</static>
      <pose>2.5 0 0.0 0 0 0</pose>
      <link name="link">
        <visual name="visual">
          <geometry>
            <mesh>
              <uri>file:///home/juptegraph/Workspaces/Robotics/Projects/CORI/cori_ws/models/Laundry_Hamper.stl</uri>
              <scale>0.01 0.01 0.01</scale>
            </mesh>
          </geometry>
          <material><diffuse>1 0.5 0 1</diffuse></material>
        </visual>
      </link>
    </model>

    <model name="laundry_bin_lights">
      <static>true</static>
      <pose>2.5 -0.5 0.0 0 0 0</pose>
      <link name="link">
        <visual name="visual">
          <geometry>
            <mesh>
              <uri>file:///home/juptegraph/Workspaces/Robotics/Projects/CORI/cori_ws/models/Laundry_Hamper.stl</uri>
              <scale>0.01 0.01 0.01</scale>
            </mesh>
          </geometry>
          <material><diffuse>1 1 1 1</diffuse></material>
        </visual>
      </link>
    </model>

    <!-- Lighting -->
    <light type="point" name="table_light">
      <pose>1.5 0 2 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <cast_shadows>false</cast_shadows>
    </light>
  </world>
</sdf>
=== ./src/database/cori_spatial_database.json ===
{
  "metadata": {
    "created": "2025-06-26 19:39:18",
    "description": "CORI Spatial Object Database",
    "version": "3.0"
  },
  "objects": {},
  "laundry_data": {
    "total_items_sorted": 5,
    "hamper_counts": {
      "Lights": 0,
      "Darks": 1,
      "Colors": 4
    },
    "learning_database": {
      "red": "Colors",
      "blue": "Darks",
      "orange": "Colors",
      "purple": "Colors"
    },
    "user_corrections": [],
    "confidence_level": "learning",
    "custom_colors": {},
    "sorted_items_history": [
      {
        "item_name": "Red Pants (johnathan)",
        "category": "Colors",
        "timestamp": 1750967397.6291525,
        "color": "red"
      },
      {
        "item_name": "Blue Jeans (johnathan)",
        "category": "Darks",
        "timestamp": 1750967405.3150375,
        "color": "blue"
      },
      {
        "item_name": "Orange Pants (johnathan)",
        "category": "Colors",
        "timestamp": 1750967416.5319295,
        "color": "orange"
      },
      {
        "item_name": "Purple Shirt (johnathan)",
        "category": "Colors",
        "timestamp": 1750967425.7983842,
        "color": "purple"
      },
      {
        "item_name": "Red Shirt (johnathan)",
        "category": "Colors",
        "timestamp": 1750969765.4704213,
        "color": "red"
      }
    ],
    "user_profile": {
      "johnathan": {
        "last_used": "2025-06-26 20:47:44"
      },
      "john": {
        "last_used": "2025-06-26 18:27:44"
      },
      "wesley": {
        "created": "2025-06-26 18:16:29",
        "last_used": "2025-06-26 18:16:29"
      }
    }
  }
}
=== ./src/tools/cori_ignition_integration.py ===
#!/usr/bin/env python3
"""
CORI Ignition Gazebo Integration - FIXED VERSION
Corrected joint names and detection throttling
"""

import json
import time
import math
import threading
import queue
import os
import sys
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum

# ROS2 imports
try:
    import rclpy
    from rclpy.node import Node
    from sensor_msgs.msg import Image
    from std_msgs.msg import String, Float64
    from cv_bridge import CvBridge
    import cv2
    import numpy as np
    ROS_AVAILABLE = True
    print("✅ ROS2 modules loaded successfully")
except ImportError as e:
    print(f"❌ ROS2 import failed: {e}")
    ROS_AVAILABLE = False

class CORIMode(Enum):
    """Operation modes for CORI with Ignition"""
    CAMERA_ONLY = "camera_only"
    IGNITION_FULL = "ignition_full"
    LAUNDRY_CAMERA = "laundry_camera"
    DATABASE_ONLY = "database_only"

@dataclass
class DetectionEvent:
    """Structure for detection events"""
    color: str
    confidence: float
    timestamp: float
    context: str = ""
    item_type: str = ""

class IgnitionCORIDatabase:
    """Database manager optimized for your Ignition setup"""
    
    def __init__(self, database_file: str = None):
        if database_file is None:
            workspace_path = "/home/juptegraph/Workspaces/Robotics/Projects/CORI/cori_ws"
            database_file = f"{workspace_path}/src/tools/cori_ignition_database.json"
        
        self.database_file = database_file
        self.ensure_database_directory()
        self.database = self.load_database()
    
    def ensure_database_directory(self):
        """Create database directory if it doesn't exist"""
        db_dir = os.path.dirname(self.database_file)
        if not os.path.exists(db_dir):
            os.makedirs(db_dir, exist_ok=True)
            print(f"📁 Created database directory: {db_dir}")
    
    def load_database(self) -> Dict:
        """Load or create database"""
        default_db = {
            "metadata": {
                "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "description": "CORI Ignition Gazebo Database",
                "version": "1.0",
                "ignition_compatible": True
            },
            "spatial_objects": {
                "red_objects": [],
                "blue_objects": [],
                "green_objects": [],
                "white_objects": [],
                "black_objects": [],
                "yellow_objects": [],
                "orange_objects": []
            },
            "ignition_data": {
                "joint_commands": [],
                "camera_calibration": {},
                "movement_history": []
            },
            "laundry_learning": {
                "total_sorted": 0,
                "user_preferences": {},
                "color_categories": {
                    "lights": ["white", "yellow", "light_grey", "cream"],
                    "darks": ["black", "dark_blue", "navy", "brown"],
                    "colors": ["red", "blue", "green", "orange", "purple"]
                }
            },
            "detection_history": []
        }
        
        try:
            with open(self.database_file, 'r') as f:
                db = json.load(f)
                print(f"📖 Loaded existing database: {self.database_file}")
                return db
        except FileNotFoundError:
            print(f"🆕 Creating new database: {self.database_file}")
            self.save_database(default_db)
            return default_db
        except json.JSONDecodeError:
            print(f"⚠️  Database corrupted, creating backup and new one")
            return default_db
    
    def save_database(self, db_data=None):
        """Save database to file"""
        if db_data is None:
            db_data = self.database
            
        try:
            with open(self.database_file, 'w') as f:
                json.dump(db_data, f, indent=2)
            return True
        except Exception as e:
            print(f"❌ Failed to save database: {e}")
            return False
    
    def log_detection(self, event: DetectionEvent):
        """Log detection event"""
        detection_record = {
            "timestamp": event.timestamp,
            "color": event.color,
            "confidence": event.confidence,
            "context": event.context,
            "item_type": event.item_type
        }
        
        self.database["detection_history"].append(detection_record)
        
        # Keep only last 500 detections
        if len(self.database["detection_history"]) > 500:
            self.database["detection_history"] = self.database["detection_history"][-500:]
        
        self.save_database()

class IgnitionCameraHandler:
    """Handle camera detection for Ignition Gazebo with throttling"""
    
    def __init__(self, node_name: str = "cori_ignition_camera"):
        self.node = None
        self.bridge = None
        self.detection_callbacks = []
        
        # Detection throttling
        self.last_detection_time = 0
        self.detection_interval = 1.0  # Only detect every 1 second
        self.last_detected_color = "unknown"
        self.stable_detection_count = 0
        self.required_stable_detections = 3
        
        # Color detection parameters (tuned for your NexiGo camera)
        self.color_ranges = {
                'red': {
                    'lower1': np.array([0, 120, 70]),
                    'upper1': np.array([10, 255, 255]),
                    'lower2': np.array([170, 120, 70]),
                    'upper2': np.array([180, 255, 255])
                },
                'blue': {
                    'lower': np.array([100, 150, 70]),
                    'upper': np.array([130, 255, 255])
                },
                'green': {
                    'lower': np.array([40, 120, 70]),
                    'upper': np.array([80, 255, 255])
                },
                'yellow': {
                    'lower': np.array([20, 100, 100]),
                    'upper': np.array([30, 255, 255])
                },
                'orange': {
                    'lower': np.array([10, 100, 100]),
                    'upper': np.array([20, 255, 255])
                },
                'purple': {
                    'lower': np.array([130, 100, 100]),
                    'upper': np.array([160, 255, 255])
                },
                'black': {
                    'lower': np.array([0, 0, 0]),
                    'upper': np.array([180, 255, 50])
                },
                'white': {
                    'lower': np.array([0, 0, 200]),
                    'upper': np.array([180, 55, 255])
                },
                'grey': {
                    'lower': np.array([0, 0, 80]),
                    'upper': np.array([180, 50, 200])
                }
        }

        
        if ROS_AVAILABLE:
            self.setup_ros()
    
    def setup_ros(self):
        """Setup ROS2 node for camera handling"""
        try:
            if not rclpy.ok():
                rclpy.init()
            
            self.node = rclpy.create_node('cori_ignition_camera')
            self.bridge = CvBridge()
            
            # Subscribe to your existing camera topic
            self.camera_sub = self.node.create_subscription(
                Image,
                '/camera/color/image_raw',
                self.camera_callback,
                10
            )
            
            # Publisher for detected colors
            self.color_pub = self.node.create_publisher(
                String,
                '/cori/color_detected',
                10
            )
            
            print("✅ Camera handler initialized with Ignition topics")
            
        except Exception as e:
            print(f"❌ ROS setup failed: {e}")
    
    def add_detection_callback(self, callback):
        """Add callback for when colors are detected"""
        self.detection_callbacks.append(callback)
    
    def camera_callback(self, msg):
        """Process camera images with throttling"""
        current_time = time.time()
        
        # Throttle detection rate
        if current_time - self.last_detection_time < self.detection_interval:
            return
        
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
            detected_color = self.detect_dominant_color(cv_image)
            
            # Require stable detections
            if detected_color == self.last_detected_color:
                self.stable_detection_count += 1
            else:
                self.stable_detection_count = 1
                self.last_detected_color = detected_color
            
            # Only process stable detections
            if detected_color != "unknown" and self.stable_detection_count >= self.required_stable_detections:
                # Create detection event
                event = DetectionEvent(
                    color=detected_color,
                    confidence=0.85,
                    timestamp=current_time,
                    context="ignition_camera"
                )
                
                # Update last detection time
                self.last_detection_time = current_time
                
                # Notify all callbacks
                for callback in self.detection_callbacks:
                    try:
                        callback(event)
                    except Exception as e:
                        print(f"⚠️  Callback error: {e}")
                
                # Publish to ROS topic
                color_msg = String()
                color_msg.data = detected_color
                self.color_pub.publish(color_msg)
                
        except Exception as e:
            print(f"❌ Camera callback error: {e}")
    
    def detect_dominant_color(self, image):
        """Detect dominant color in image center"""
        height, width = image.shape[:2]
        center_x, center_y = width // 2, height // 2
        roi_size = min(width, height) // 6
        
        # Extract center region
        roi = image[
            center_y - roi_size:center_y + roi_size,
            center_x - roi_size:center_x + roi_size
        ]
        
        # Convert to HSV
        hsv_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        
        # Test each color
        best_score = 0
        best_color = "unknown"
        
        for color_name, ranges in self.color_ranges.items():
            if color_name == 'red':
                # Special handling for red (wraps around hue)
                mask1 = cv2.inRange(hsv_roi, ranges['lower1'], ranges['upper1'])
                mask2 = cv2.inRange(hsv_roi, ranges['lower2'], ranges['upper2'])
                mask = cv2.bitwise_or(mask1, mask2)
            else:
                mask = cv2.inRange(hsv_roi, ranges['lower'], ranges['upper'])
            
            score = np.sum(mask) / 255
            if score > best_score and score > 200:  # Minimum threshold
                best_score = score
                best_color = color_name
        
        return best_color

class IgnitionRobotController:
    """Control CORI robot in Ignition Gazebo - FIXED JOINT NAMES"""
    
    def __init__(self, node_name: str = "cori_ignition_controller"):
        self.node = None
        self.joint_publishers = {}
        self.current_angles = {}
        
        if ROS_AVAILABLE:
            self.setup_ros()
    
    def setup_ros(self):
        """Setup ROS2 publishers for Ignition joints"""
        try:
            if not rclpy.ok():
                rclpy.init()
            
            self.node = rclpy.create_node('cori_ignition_controller')
            
            # CORRECTED: Your robot uses head_joint, not head_pan_joint/head_tilt_joint
            joint_topics = {
                'head': '/model/cori/joint/head_joint/cmd_pos',
            }
            
            # Create publishers for each joint
            for joint_name, topic in joint_topics.items():
                self.joint_publishers[joint_name] = self.node.create_publisher(
                    Float64,
                    topic,
                    10
                )
                self.current_angles[joint_name] = 0.0
                print(f"✅ Connected to joint: {topic}")
            
            print(f"✅ Robot controller initialized with {len(joint_topics)} joints")
            
        except Exception as e:
            print(f"❌ Robot controller setup failed: {e}")
    

    # This is what will be replaced with a database
    def move_head_to_color(self, color: str):
        """Move head based on detected color - FIXED COMMANDS"""
        # Updated color-to-angle mapping
        color_angles = {
    'black':  0.76,
    'grey':   0.62,
    'purple': 0.45,
    'blue':   0.23,
    'green':  0.0,
    'yellow': -0.23,
    'orange': -0.45,
    'red':    -0.62
    }
        
        target_angle = color_angles.get(color, 0.0)
        self.move_head(target_angle)
        
        angle_degrees = math.degrees(target_angle)
        direction = "LEFT" if target_angle < 0 else "RIGHT" if target_angle > 0 else "CENTER"
        print(f"🤖 Moving head {direction} ({angle_degrees:.1f}°) for {color} object")
    
    def move_head(self, angle_rad: float):
        """Move head joint to specified angle"""
        if 'head' in self.joint_publishers:
            msg = Float64()
            msg.data = float(angle_rad)
            self.joint_publishers['head'].publish(msg)
            self.current_angles['head'] = angle_rad
            print(f"📡 Sent head command: {angle_rad:.2f} rad")

class CORIIgnitionSystem:
    """Main CORI system for Ignition Gazebo - FIXED VERSION"""
    
    def __init__(self, mode: CORIMode = CORIMode.CAMERA_ONLY):
        self.mode = mode
        self.database = IgnitionCORIDatabase()
        self.camera_handler = None
        self.robot_controller = None
        
        print(f"🤖 Initializing CORI for Ignition Gazebo in {mode.value} mode")
        
        # Initialize components based on mode
        self.setup_components()
        
        # Start ROS spinning in background thread
        self.ros_thread = None
        if ROS_AVAILABLE:
            self.start_ros_spinning()
    
    def setup_components(self):
        """Setup components based on mode"""
        if self.mode in [CORIMode.CAMERA_ONLY, CORIMode.IGNITION_FULL, CORIMode.LAUNDRY_CAMERA]:
            self.camera_handler = IgnitionCameraHandler()
            self.camera_handler.add_detection_callback(self.handle_detection)
        
        if self.mode in [CORIMode.IGNITION_FULL, CORIMode.LAUNDRY_CAMERA]:
            self.robot_controller = IgnitionRobotController()
    
    def start_ros_spinning(self):
        """Start ROS2 spinning in background thread"""
        def spin_nodes():
            while rclpy.ok():
                try:
                    if self.camera_handler and self.camera_handler.node:
                        rclpy.spin_once(self.camera_handler.node, timeout_sec=0.1)
                    if self.robot_controller and self.robot_controller.node:
                        rclpy.spin_once(self.robot_controller.node, timeout_sec=0.1)
                except Exception as e:
                    print(f"⚠️  ROS spinning error: {e}")
                    break
        
        self.ros_thread = threading.Thread(target=spin_nodes, daemon=True)
        self.ros_thread.start()
        print("✅ ROS spinning started in background")
    
    def handle_detection(self, event: DetectionEvent):
        """Handle color detection events"""
        print(f"👁️  Detected {event.color} (confidence: {event.confidence:.2f})")
        
        # Log to database
        self.database.log_detection(event)
        
        # Move robot if in full mode
        if self.mode in [CORIMode.IGNITION_FULL, CORIMode.LAUNDRY_CAMERA] and self.robot_controller:
            self.robot_controller.move_head_to_color(event.color)
        
        # Handle laundry sorting if in laundry mode
        if self.mode == CORIMode.LAUNDRY_CAMERA:
            self.suggest_laundry_category(event.color)
    
    def suggest_laundry_category(self, color: str):
        """Suggest laundry category for detected color"""
        categories = self.database.database["laundry_learning"]["color_categories"]
        
        for category, colors in categories.items():
            if color in colors:
                print(f"🧺 Suggestion: {color} → {category.upper()} hamper")
                return category
        
        print(f"🤔 Unknown color: {color} - please teach me where it goes!")
        return "unknown"
    
    def show_menu(self):
        """Show interactive menu"""
        while True:
            print("\n" + "="*50)
            print("🤖 CORI IGNITION GAZEBO SYSTEM - FIXED VERSION")
            print("="*50)
            print(f"Current Mode: {self.mode.value}")
            print(f"Camera Status: {'✅ Active' if self.camera_handler else '❌ Disabled'}")
            print(f"Robot Control: {'✅ Active' if self.robot_controller else '❌ Disabled'}")
            print()
            print("Options:")
            print("1. Test camera detection")
            print("2. Manual robot control")
            print("3. View detection history") 
            print("4. Laundry sorting mode")
            print("5. Database statistics")
            print("6. Change mode")
            print("7. Exit")
            
            choice = input("\nChoose (1-7): ").strip()
            
            if choice == "1":
                self.test_camera()
            elif choice == "2":
                self.manual_robot_control()
            elif choice == "3":
                self.show_detection_history()
            elif choice == "4":
                self.laundry_mode()
            elif choice == "5":
                self.show_database_stats()
            elif choice == "6":
                self.change_mode()
            elif choice == "7":
                self.shutdown()
                break
            else:
                print("❌ Invalid choice")
    
    def test_camera(self):
        """Test camera detection"""
        if not self.camera_handler:
            print("❌ Camera not available in current mode")
            return
        
        print("\n📷 Camera Detection Test - THROTTLED")
        print("Hold colored objects in front of camera...")
        print("⏱️  Detection rate: 1 per second (no more spam!)")
        print("🎯 Try: red, blue, green, white objects")
        print("Press Enter to stop")
        
        input()
        print("✅ Camera test complete")
    
    def manual_robot_control(self):
        """Manual robot control interface"""
        if not self.robot_controller:
            print("❌ Robot control not available in current mode")
            return
        
        print("\n🤖 Manual Robot Control - FIXED COMMANDS")
        print("Commands: left, right, center, test, quit")
        
        while True:
            cmd = input("Robot> ").strip().lower()
            
            if cmd == "quit":
                break
            elif cmd == "left":
                self.robot_controller.move_head(-0.5)
                print("👈 Head moved left")
            elif cmd == "right":
                self.robot_controller.move_head(0.5)
                print("👉 Head moved right")
            elif cmd == "center":
                self.robot_controller.move_head(0.0)
                print("🎯 Head centered")
            elif cmd == "test":
                print("🧪 Testing movement sequence...")
                self.robot_controller.move_head(-0.5)
                time.sleep(1)
                self.robot_controller.move_head(0.5)
                time.sleep(1)
                self.robot_controller.move_head(0.0)
                print("✅ Test complete")
            else:
                print("❌ Unknown command. Try: left, right, center, test, quit")
    
    def show_detection_history(self):
        """Show recent detection history"""
        history = self.database.database["detection_history"]
        
        print("\n📊 Recent Detections:")
        if not history:
            print("No detections recorded yet")
            return
        
        recent = history[-10:]
        for i, detection in enumerate(recent, 1):
            timestamp = datetime.fromtimestamp(detection["timestamp"])
            print(f"{i:2d}. {detection['color']:8s} "
                  f"({detection['confidence']:.2f}) "
                  f"at {timestamp.strftime('%H:%M:%S')}")
    
    def show_database_stats(self):
        """Show database statistics"""
        db = self.database.database
        
        print("\n📊 Database Statistics:")
        print(f"Total detections: {len(db['detection_history'])}")
        print(f"Laundry items sorted: {db['laundry_learning']['total_sorted']}")
        
        # Color frequency
        if db['detection_history']:
            colors = [d['color'] for d in db['detection_history']]
            color_counts = {}
            for color in colors:
                color_counts[color] = color_counts.get(color, 0) + 1
            
            print("\nColor frequency:")
            for color, count in sorted(color_counts.items(), key=lambda x: x[1], reverse=True):
                print(f"  {color}: {count}")
    
    def laundry_mode(self):
        """Interactive laundry sorting"""
        print("\n🧺 Laundry Sorting Mode")
        print("Show me clothing items and I'll suggest which hamper!")
        print("Commands: 'done' to exit, 'teach [color] [category]' to train")
        
        while True:
            cmd = input("\nLaundry> ").strip().lower()
            
            if cmd == "done":
                break
            elif cmd.startswith("teach"):
                parts = cmd.split()
                if len(parts) == 3:
                    color, category = parts[1], parts[2]
                    self.teach_color_category(color, category)
                else:
                    print("Usage: teach [color] [category]")
            else:
                print("Hold up a clothing item for automatic detection...")
    
    def teach_color_category(self, color: str, category: str):
        """Teach color categorization"""
        valid_categories = ["lights", "darks", "colors"]
        if category not in valid_categories:
            print(f"❌ Category must be one of: {', '.join(valid_categories)}")
            return
        
        categories = self.database.database["laundry_learning"]["color_categories"]
        
        # Remove color from other categories
        for cat, colors in categories.items():
            if color in colors:
                colors.remove(color)
        
        # Add to new category
        categories[category].append(color)
        self.database.save_database()
        
        print(f"✅ Learned: {color} → {category}")
    
    def change_mode(self):
        """Change operation mode"""
        print("\nAvailable modes:")
        for i, mode in enumerate(CORIMode, 1):
            print(f"{i}. {mode.value}")
        
        try:
            choice = int(input("Choose mode: ")) - 1
            if 0 <= choice < len(CORIMode):
                new_mode = list(CORIMode)[choice]
                self.__init__(new_mode)
                print(f"✅ Switched to {new_mode.value} mode")
            else:
                print("❌ Invalid choice")
        except ValueError:
            print("❌ Please enter a number")
    
    def shutdown(self):
        """Shutdown system"""
        print("\n🔄 Shutting down CORI Ignition system...")
        
        # Save final database state
        self.database.save_database()
        print("💾 Database saved")
        
        # Shutdown ROS
        if ROS_AVAILABLE:
            try:
                rclpy.shutdown()
                print("✅ ROS shutdown complete")
            except:
                pass
        
        print("👋 CORI shutdown complete!")

def main():
    """Main entry point"""
    print("🤖 CORI Ignition Gazebo System - FIXED VERSION")
    print("✅ Fixed joint names and detection throttling")
    print()
    
    # Check if ROS2 topics are available
    if ROS_AVAILABLE:
        try:
            rclpy.init()
            temp_node = rclpy.create_node('cori_topic_checker')
            
            topic_names = temp_node.get_topic_names_and_types()
            topic_list = [name for name, _ in topic_names]
            
            camera_available = any('/camera' in topic for topic in topic_list)
            cori_available = any('/cori' in topic for topic in topic_list)
            
            temp_node.destroy_node()
            rclpy.shutdown()
            
            print(f"📷 Camera topics: {'✅ Found' if camera_available else '❌ Not found'}")
            print(f"🤖 CORI topics: {'✅ Found' if cori_available else '❌ Not found'}")
            print()
            
        except Exception as e:
            print(f"⚠️  Could not check topics: {e}")
    
    # Mode selection
    print("Select operation mode:")
    for i, mode in enumerate(CORIMode, 1):
        print(f"{i}. {mode.value.replace('_', ' ').title()}")
    
    try:
        choice = int(input("\nChoose mode (1-4): ")) - 1
        if 0 <= choice < len(CORIMode):
            selected_mode = list(CORIMode)[choice]
        else:
            print("Invalid choice, using Camera Only mode")
            selected_mode = CORIMode.CAMERA_ONLY
    except ValueError:
        print("Invalid input, using Camera Only mode")
        selected_mode = CORIMode.CAMERA_ONLY
    
    # Initialize and run system
    try:
        system = CORIIgnitionSystem(selected_mode)
        system.show_menu()
    except KeyboardInterrupt:
        print("\n⏸️  Interrupted by user")
    except Exception as e:
        print(f"\n❌ System error: {e}")
    finally:
        print("👋 Thanks for using CORI!")

if __name__ == "__main__":
    main()
=== ./src/tools/cori_info_collector.sh ===
#!/bin/bash
# CORI System Information Collector
# Run this script to gather all system info for integration planning

# Create output file with timestamp
OUTPUT_FILE="cori_system_info_$(date +%Y%m%d_%H%M%S).txt"

echo "🤖 CORI System Information Collector"
echo "📋 Gathering system information for integration planning..."
echo "💾 Output will be saved to: $OUTPUT_FILE"
echo ""

# Function to run command and capture output safely
run_cmd() {
    local description="$1"
    local command="$2"
    echo "▶ $description" | tee -a "$OUTPUT_FILE"
    echo "Command: $command" >> "$OUTPUT_FILE"
    
    # Run command and capture both stdout and stderr
    if output=$(eval "$command" 2>&1); then
        echo "$output" | tee -a "$OUTPUT_FILE"
        echo "✅ Success" >> "$OUTPUT_FILE"
    else
        echo "❌ Failed: $output" | tee -a "$OUTPUT_FILE"
    fi
    echo "" | tee -a "$OUTPUT_FILE"
}

# Function to check if file/directory exists
check_path() {
    local description="$1"
    local path="$2"
    echo "▶ $description" | tee -a "$OUTPUT_FILE"
    if [ -e "$path" ]; then
        ls -la "$path" | tee -a "$OUTPUT_FILE"
        echo "✅ Found" >> "$OUTPUT_FILE"
    else
        echo "❌ Not found: $path" | tee -a "$OUTPUT_FILE"
    fi
    echo "" | tee -a "$OUTPUT_FILE"
}

# Start collecting information
{
    echo "🤖 CORI SYSTEM INFORMATION REPORT"
    echo "Generated: $(date)"
    echo "Host: $(hostname)"
    echo "User: $(whoami)"
    echo "Current Directory: $(pwd)"
    echo "================================================================"
    echo ""
} > "$OUTPUT_FILE"

echo "🖥️  Collecting Operating System Information..."
run_cmd "Linux Distribution" "lsb_release -a"
run_cmd "Kernel Version" "uname -a"
run_cmd "System Architecture" "arch"
run_cmd "Available Memory" "free -h"
run_cmd "Disk Space" "df -h /"

echo "🐍 Collecting Python Information..."
run_cmd "Python3 Version" "python3 --version"
run_cmd "Python3 Location" "which python3"
run_cmd "Pip3 Version" "pip3 --version"
run_cmd "Pip3 Location" "which pip3"
run_cmd "Active Virtual Environment" "echo \$VIRTUAL_ENV"
run_cmd "Python Path" "python3 -c 'import sys; print(\"\\n\".join(sys.path))'"

echo "🤖 Collecting ROS2 Information..."
run_cmd "ROS2 Version" "ros2 --version"
run_cmd "ROS2 Distribution" "echo \$ROS_DISTRO"
run_cmd "ROS2 Location" "which ros2"
run_cmd "ROS2 Environment Variables" "env | grep ROS"
run_cmd "Available ROS2 Packages (first 10)" "ros2 pkg list | head -10"
run_cmd "ROS2 Topics (if any)" "timeout 3 ros2 topic list"
run_cmd "ROS2 Nodes (if any)" "timeout 3 ros2 node list"

echo "🎮 Collecting Gazebo Information..."
run_cmd "Gazebo Version" "gazebo --version"
run_cmd "Gazebo Location" "which gazebo"
run_cmd "Gazebo Models Path" "echo \$GAZEBO_MODEL_PATH"
run_cmd "Gazebo Plugins Path" "echo \$GAZEBO_PLUGIN_PATH"

echo "📷 Collecting Camera Information..."
run_cmd "Video Devices" "ls -la /dev/video* 2>/dev/null || echo 'No video devices found'"
run_cmd "USB Devices" "lsusb | grep -i camera || echo 'No USB cameras found'"
run_cmd "V4L2 Utils Check" "which v4l2-ctl"
run_cmd "Camera Device Info" "v4l2-ctl --list-devices 2>/dev/null || echo 'v4l-utils not installed'"

echo "📦 Collecting Python Package Information..."
run_cmd "OpenCV" "python3 -c 'import cv2; print(f\"OpenCV: {cv2.__version__}\")' 2>/dev/null || echo 'OpenCV not installed'"
run_cmd "NumPy" "python3 -c 'import numpy; print(f\"NumPy: {numpy.__version__}\")' 2>/dev/null || echo 'NumPy not installed'"
run_cmd "ROS2 Python (rclpy)" "python3 -c 'import rclpy; print(\"rclpy available\")' 2>/dev/null || echo 'rclpy not installed'"
run_cmd "CV Bridge" "python3 -c 'from cv_bridge import CvBridge; print(\"cv_bridge available\")' 2>/dev/null || echo 'cv_bridge not installed'"
run_cmd "All Installed Packages" "pip3 list"

echo "📁 Collecting Workspace Information..."
check_path "Current Directory Contents" "."
check_path "ROS2 Workspace (~/colcon_ws)" "$HOME/colcon_ws"
check_path "Alternative Workspace (~/ros2_ws)" "$HOME/ros2_ws"
check_path "Development Directory (~/dev)" "$HOME/dev"
check_path "CORI Files in Current Directory" "*.py"
check_path "CORI Text Files" "*.txt"
check_path "Database Directory" "database"

echo "🔍 Searching for CORI-related Files..."
run_cmd "Find CORI Directories" "find ~ -name '*cori*' -type d 2>/dev/null | head -10"
run_cmd "Find CORI Files" "find ~ -name '*cori*' -type f 2>/dev/null | head -10"
run_cmd "Find Launch Files" "find ~ -name '*.launch*' 2>/dev/null | grep -i cori | head -5"

echo "🔧 Collecting Build Tools Information..."
run_cmd "Colcon" "which colcon"
run_cmd "CMake" "cmake --version 2>/dev/null | head -1"
run_cmd "Make" "make --version 2>/dev/null | head -1"
run_cmd "GCC" "gcc --version 2>/dev/null | head -1"

echo "🌐 Collecting Network Information..."
run_cmd "Network Interfaces" "ip addr show | grep -E '^[0-9]+:' -A 2"
run_cmd "ROS Domain ID" "echo \$ROS_DOMAIN_ID"
run_cmd "Localhost Check" "ping -c 1 localhost 2>/dev/null || echo 'Localhost not reachable'"

echo "⚡ Testing CORI Files..."
if [ -f "paste.txt" ]; then
    echo "▶ Testing Database Manager (paste.txt)" | tee -a "$OUTPUT_FILE"
    python3 -c "
import sys
sys.path.append('.')
try:
    with open('paste.txt', 'r') as f:
        content = f.read()
    if 'CORIDatabaseManager' in content:
        print('✅ Database Manager file found and contains expected class')
    else:
        print('⚠️  Database Manager file found but may be incomplete')
except Exception as e:
    print(f'❌ Error reading Database Manager: {e}')
" | tee -a "$OUTPUT_FILE"
else
    echo "❌ paste.txt (Database Manager) not found" | tee -a "$OUTPUT_FILE"
fi

if [ -f "paste-2.txt" ]; then
    echo "▶ Testing Sensor Fusion (paste-2.txt)" | tee -a "$OUTPUT_FILE"
    python3 -c "
try:
    with open('paste-2.txt', 'r') as f:
        content = f.read()
    if 'SensorFusionDemo' in content:
        print('✅ Sensor Fusion file found and contains expected class')
    else:
        print('⚠️  Sensor Fusion file found but may be incomplete')
except Exception as e:
    print(f'❌ Error reading Sensor Fusion: {e}')
" | tee -a "$OUTPUT_FILE"
else
    echo "❌ paste-2.txt (Sensor Fusion) not found" | tee -a "$OUTPUT_FILE"
fi

if [ -f "paste-3.txt" ]; then
    echo "▶ Testing Laundry Assistant (paste-3.txt)" | tee -a "$OUTPUT_FILE"
    python3 -c "
try:
    with open('paste-3.txt', 'r') as f:
        content = f.read()
    if 'CORILaundryAssistant' in content:
        print('✅ Laundry Assistant file found and contains expected class')
    else:
        print('⚠️  Laundry Assistant file found but may be incomplete')
except Exception as e:
    print(f'❌ Error reading Laundry Assistant: {e}')
" | tee -a "$OUTPUT_FILE"
else
    echo "❌ paste-3.txt (Laundry Assistant) not found" | tee -a "$OUTPUT_FILE"
fi

echo "" | tee -a "$OUTPUT_FILE"

# Summary Section
{
    echo "================================================================"
    echo "📊 INTEGRATION READINESS SUMMARY"
    echo "================================================================"
    echo ""
    
    echo "🟢 READY COMPONENTS:"
    echo "-------------------"
} >> "$OUTPUT_FILE"

# Check for ready components
python3 --version >/dev/null 2>&1 && echo "✅ Python3 installed" >> "$OUTPUT_FILE"
ros2 --version >/dev/null 2>&1 && echo "✅ ROS2 installed" >> "$OUTPUT_FILE"
gazebo --version >/dev/null 2>&1 && echo "✅ Gazebo installed" >> "$OUTPUT_FILE"
[ -f "paste.txt" ] && echo "✅ Database Manager available" >> "$OUTPUT_FILE"
[ -f "paste-2.txt" ] && echo "✅ Sensor Fusion available" >> "$OUTPUT_FILE"
[ -f "paste-3.txt" ] && echo "✅ Laundry Assistant available" >> "$OUTPUT_FILE"

{
    echo ""
    echo "⚠️  POTENTIAL ISSUES:"
    echo "--------------------"
} >> "$OUTPUT_FILE"

# Check for potential issues
python3 -c "import cv2" >/dev/null 2>&1 || echo "❌ OpenCV not installed" >> "$OUTPUT_FILE"
python3 -c "import rclpy" >/dev/null 2>&1 || echo "❌ rclpy not installed" >> "$OUTPUT_FILE"
[ -z "$ROS_DISTRO" ] && echo "❌ ROS2 environment not sourced" >> "$OUTPUT_FILE"
[ ! -d "/dev/" ] || [ -z "$(ls /dev/video* 2>/dev/null)" ] && echo "⚠️  No camera devices detected" >> "$OUTPUT_FILE"

{
    echo ""
    echo "📝 RECOMMENDED NEXT STEPS:"
    echo "-------------------------"
    echo "1. Review the complete report above"
    echo "2. Install any missing packages identified"
    echo "3. Source ROS2 environment if needed"
    echo "4. Test individual CORI components"
    echo "5. Proceed with integration based on findings"
    echo ""
    echo "================================================================"
    echo "Report generated: $(date)"
    echo "Report saved to: $OUTPUT_FILE"
    echo "================================================================"
} >> "$OUTPUT_FILE"

echo ""
echo "✅ System information collection complete!"
echo "📄 Full report saved to: $OUTPUT_FILE"
echo ""
echo "📋 Quick Summary:"
python3 --version >/dev/null 2>&1 && echo "✅ Python3: Ready" || echo "❌ Python3: Missing"
ros2 --version >/dev/null 2>&1 && echo "✅ ROS2: Ready" || echo "❌ ROS2: Missing" 
gazebo --version >/dev/null 2>&1 && echo "✅ Gazebo: Ready" || echo "❌ Gazebo: Missing"
[ -f "paste.txt" ] && echo "✅ CORI Files: Found" || echo "❌ CORI Files: Missing"
echo ""
echo "📨 Share the file '$OUTPUT_FILE' for personalized integration guidance!"

=== ./build.bash ===
#!/bin/bash
# CORI Robot Build and Run Script - Cooperative Organizational Robotic Intelligence
# Description: Unified build and execution for CORI's laundry sorting system
# Constants
WORKSPACE_DIR="/home/juptegraph/Workspaces/Robotics/Projects/CORI/cori_ws"
SENSOR_FUSION_PATH="src/cori_cv/cori_cv/sensor_fusion/spatial_database.py"
INTEGRATION_PATH="src/tools/cori_ignition_integration.py"
WORLD_FILE="src/cori_description/worlds/laundry_world.sdf"
URDF_FILE="src/cori_description/urdf/cori.urdf.xacro"

# Function to display a loading bar
show_loading_bar() {
    local duration=$1
    local bar_length=20
    local sleep_time=$(echo "scale=2; $duration / $bar_length" | bc)

    echo -ne "   ["
    for i in $(seq 1 $bar_length); do
        printf "\e[32m█\e[0m"
        sleep $sleep_time
    done
    echo -e "]\n"
}

# Display startup sequence
show_startup_sequence() {
    echo -e "\n🤖 Initializing C.O.R.I. system...."
    show_loading_bar 1
    
    # --- Start of Banner Box (Using rounded borders) ---
    local TOTAL_BOX_WIDTH=70
    local banner_inner_width=$((TOTAL_BOX_WIDTH - 2)) 

    # Top border - now rounded
    echo -e "\n╭"$(printf '─%.0s' $(seq 1 $banner_inner_width))"╮"

    # Blank line inside banner
    printf "│%*s│\n" $banner_inner_width ""

local banner_lines=(
    "    ██████╗    ██████╗    ██████╗    ██╗    "
    "   ██╔════╝   ██╔═══██╗   ██╔══██╗   ██║    "
    "   ██║        ██║   ██║   ██████╔╝   ██║    "
    "   ██║        ██║   ██║   ██╔══██╗   ██║    "
    "   ╚██████╗██╗╚██████╔╝██╗██║  ██║██╗██║ ██╗"
    "    ╚═════╝╚═╝ ╚═════╝ ╚═╝╚═╝  ╚═╝╚═╝╚═╝ ╚═╝"
)

    for line in "${banner_lines[@]}"; do
        local len=${#line}
        local padding_left=$(( (banner_inner_width - len) / 2 ))
        local padding_right=$(( banner_inner_width - len - padding_left ))
        printf "│%*s%s%*s│\n" $padding_left "" "$line" $padding_right ""
    done

    # Blank line inside banner
    printf "│%*s│\n" $banner_inner_width ""

    local text_lines=(
        "Cooperative Organizational Robotic Intelligence"
        "Developed by Johnathan Uptegraph - 2025"
        "Built to function, designed to matter."
    )
    for text_line in "${text_lines[@]}"; do
        local len=${#text_line}
        local padding_left=$(( (banner_inner_width - len) / 2 ))
        local padding_right=$(( banner_inner_width - len - padding_left ))
        printf "│%*s%s%*s│\n" $padding_left "" "$text_line" $padding_right ""
    done
    
    # Blank line inside banner
    printf "│%*s│\n" $banner_inner_width ""

    echo "╰"$(printf '─%.0s' $(seq 1 $banner_inner_width))"╯"
    # --- End of Banner Box ---
}

# Check if file exists
check_file() {
    local file_path="$1"
    [ -f "$file_path" ] || { echo "❌ File not found: $file_path"; return 1; }
    return 0
}

# Clean up processes
cleanup_processes() {
    local mode="$1"
    echo "🛑 Stopping $mode processes..."
    pkill -f "ros2 launch" 2>/dev/null || true
    pkill -f "ros2 run" 2>/dev/null || true
    pkill -f "ign gazebo" 2>/dev/null || true
    pkill -f "gz sim" 2>/dev/null || true
    pkill -f "v4l2_camera" 2>/dev/null || true
    pkill -f "robot_state_publisher" 2>/dev/null || true
    pkill -f "cori_cv" 2>/dev/null || true
    pkill -f "sensor_fusion" 2>/dev/null || true
    pkill -f "spatial_database" 2>/dev/null || true
    pkill -f "cori_ignition_integration" 2>/dev/null || true
    sleep 3
    echo "✅ $mode processes stopped"
}

# Build workspace
build_workspace() {
    echo "🧹 Cleaning previous build..."
    rm -rf build/ devel/ install/
    echo "🔨 Building workspace..."
    colcon build --packages-select cori_description cori_cv
    [ $? -eq 0 ] && echo "✅ Build successful!" || { echo "❌ Build failed!"; exit 1; }
    echo "📦 Sourcing workspace..."
    source install/setup.bash
}

# Start Gazebo simulation
start_gazebo() {
    local pid_var="$1"
    echo "🎮 Starting Gazebo simulation..."
    ros2 launch cori_description spawn_cori_ignition.launch.py &
    eval "$pid_var=\$!"
    sleep 8
    [ -z "$(ps -p ${!pid_var} -o pid=)" ] && { echo "❌ Gazebo failed to start!"; exit 1; }
}

# Start webcam
start_webcam() {
    local pid_var="$1"
    echo "📷 Starting webcam..."
    ros2 launch cori_cv laundry_color_detector.launch.py &
    eval "$pid_var=\$!"
    sleep 5
    [ -z "$(ps -p ${!pid_var} -o pid=)" ] && { echo "❌ Webcam failed to start!"; return 1; }
    return 0
}

# Run full system
run_full_system() {
    cleanup_processes "full system"
    trap 'cleanup_processes "full system"; exit 0' SIGINT
    start_gazebo GAZEBO_PID
    start_webcam WEBCAM_PID || { kill $GAZEBO_PID 2>/dev/null; exit 1; }
    echo "🔗 Starting color detection bridge..."
    ros2 run cori_cv simple_color_detector &
    BRIDGE_PID=$!
    sleep 3
    echo "🎨 Starting color display..."
    echo "👋 Hold colored objects in front of your webcam!"
    echo "📺 Ensure webcam permissions are enabled"
    ros2 run cori_cv color_display
    cleanup_processes "full system"
}

# Run Gazebo simulation only
run_gazebo_only() {
    cleanup_processes "Gazebo"
    trap 'cleanup_processes "Gazebo"; exit 0' SIGINT
    ros2 launch cori_description spawn_cori_ignition.launch.py
}

# Run manual control mode
run_manual_control() {
    cleanup_processes "manual control"
    trap 'cleanup_processes "manual control"; exit 0' SIGINT
    echo "🎮 Starting Gazebo..."
    ign gazebo "$WORLD_FILE" &
    GAZEBO_PID=$!
    sleep 6
    echo "🤖 Starting robot state publisher..."
    ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="$(xacro "$URDF_FILE")" &
    RSP_PID=$!
    sleep 3
    echo "🚀 Spawning CORI..."
    ros2 run ros_gz_sim create -name cori -topic robot_description
    echo "🎉 CORI is ready for manual control!"
    echo "✋ Click and drag CORI in Gazebo"
    while true; do sleep 1; [ -z "$(ps -p $GAZEBO_PID -o pid=)" ] && cleanup_processes "manual control"; done
}

# Run webcam color detection
run_webcam_color() {
    cleanup_processes "webcam color detection"
    trap 'cleanup_processes "webcam color detection"; exit 0' SIGINT
    start_webcam WEBCAM_PID || exit 1
    echo "🎨 Starting color detection..."
    ros2 run cori_cv simple_color_detector &
    BRIDGE_PID=$!
    sleep 2
    echo "👋 Hold colored objects in front of your webcam!"
    ros2 run cori_cv color_display
    cleanup_processes "webcam color detection"
}

# Run sensor fusion demo
run_sensor_fusion() {
    [ $(check_file "$SENSOR_FUSION_PATH"; echo $?) -ne 0 ] && exit 1
    echo "🧠 CORI SENSOR FUSION DEMONSTRATION"
    echo "==================================="
    echo "🎯 DEMO SEQUENCE:"
    echo "   1. Hold RED object → CORI looks LEFT (14°)"
    echo "   2. Hold BLUE object → CORI looks RIGHT (-16°)"
    echo "   3. Hold GREEN object → CORI looks STRAIGHT (0°)"
    read -p "🚀 Start sensor fusion demo? [y/N]: " confirm
    [[ ! $confirm =~ ^[Yy]$ ]] && { echo "👋 Demo cancelled"; exit 0; }
    cleanup_processes "sensor fusion"
    trap 'cleanup_processes "sensor fusion"; exit 0' SIGINT
    echo "🗃️ Initializing spatial database..."
    python3 "$SENSOR_FUSION_PATH"
    start_gazebo GAZEBO_PID
    start_webcam CAMERA_PID || { kill $GAZEBO_PID 2>/dev/null; exit 1; }
    echo "🔍 Checking camera topics..."
    ros2 topic list | grep -E "(image|camera)" || echo "No camera topics found yet, continuing..."
    echo "🧠 Starting sensor fusion processing..."
    python3 src/cori_cv/cori_cv/sensor_fusion/sensor_fusion_demo.py &
    FUSION_PID=$!
    sleep 2
    echo "🖥️ Starting demo display..."
    echo "🎯 HOLD COLORED OBJECTS IN FRONT OF CAMERA:"
    echo "   🔴 RED → LEFT"
    echo "   🔵 BLUE → RIGHT"
    echo "   🟢 GREEN → STRAIGHT"
    python3 src/cori_cv/cori_cv/sensor_fusion/demo_display.py
    cleanup_processes "sensor fusion"
}

# View spatial database
view_spatial_database() {
    [ $(check_file "$SENSOR_FUSION_PATH"; echo $?) -ne 0 ] && exit 1
    echo "🗃️ SPATIAL DATABASE MANAGEMENT"
    echo "==============================="
    python3 "$SENSOR_FUSION_PATH"
    echo "💾 Database file: database/cori_spatial_database.json"
}

# Run laundry assistant
run_laundry_assistant() {
    local script_path="src/cori_cv/cori_cv/cori_simulator.py"
    [ $(check_file "$script_path"; echo $?) -ne 0 ] && { echo "❌ Laundry assistant not found!"; exit 1; }
    echo "🧺 CORI LAUNDRY SORTING ASSISTANT"
    echo "================================="
    echo "🤖 Features:"
    echo "   📚 Learns your preferences"
    echo "   🧠 Improves with each item"
    echo "   🗂️ Sorts: Lights, Darks, Colors"
    read -p "🚀 Start laundry sorting? [y/N]: " confirm
    [[ ! $confirm =~ ^[Yy]$ ]] && { echo "👋 Cancelled"; exit 0; }
    trap 'echo -e "\n🛑 Stopping...\n💾 Progress saved!"; exit 0' SIGINT
    cd src/cori_cv/cori_cv/
    echo "🚀 Launching Laundry Assistant..."
    echo "🎯 TIPS: Start with 'red shirt', 'blue jeans'; type 'quit' to stop"
    python3 cori_simulator.py
}

# Run unified integration
run_unified_integration() {
    [ $(check_file "$INTEGRATION_PATH"; echo $?) -ne 0 ] && exit 1
    echo "🔗 CORI UNIFIED INTEGRATION SYSTEM"
    echo "=================================="
    echo "🎯 Features:"
    echo "   🎮 Gazebo simulation"
    echo "   📷 Camera detection"
    echo "   🧠 Unified database"
    read -p "🚀 Start integration? [y/N]: " confirm
    [[ ! $confirm =~ ^[Yy]$ ]] && { echo "👋 Cancelled"; exit 0; }
    cleanup_processes "unified integration"
    trap 'cleanup_processes "unified integration"; exit 0' SIGINT
    start_gazebo GAZEBO_PID
    start_webcam CAMERA_PID || { kill $GAZEBO_PID 2>/dev/null; exit 1; }
    echo "🔍 Verifying integration..."
    ros2 topic list | grep -q "/camera/color/image_raw" || echo "   ⚠️ Camera topic not found"
    ros2 topic list | grep -q "head_pan_joint" || echo "   ⚠️ Joint topic not found"
    echo "🔗 Starting integration system..."
    cd src/tools/
    python3 cori_ignition_integration.py
    cleanup_processes "unified integration"
}

# Kill all processes
kill_all_processes() {
    cleanup_processes "all ROS"
    echo "📷 Camera devices: $(ls /dev/video* 2>/dev/null | tr '\n' ' ')"
    exit 0
}

# Main execution
main() {
    cd "$WORKSPACE_DIR" || { echo "❌ Failed to navigate to $WORKSPACE_DIR"; exit 1; }
    echo "📁 Current directory: $(pwd)"
    build_workspace
    show_startup_sequence

    # --- Start of Menu Box ---
    local TOTAL_MENU_WIDTH=70
    local menu_inner_width=$((TOTAL_MENU_WIDTH))
    local menu_padding=2  # Left padding for menu items

    echo "╭"$(printf '─%.0s' $(seq 1 $menu_inner_width))"╮"

    # Menu title with centered alignment
    local menu_title="SELECT A PROGRAM TO RUN:"
    local title_len=${#menu_title}
    local title_pad_left=$(( (menu_inner_width - title_len) / 2 ))
    printf "│%*s%s%*s│\n" $title_pad_left "" "$menu_title" $((menu_inner_width - title_len - title_pad_left)) ""

    # Empty line after title
    printf "│%*s│\n" $menu_inner_width ""

    # Menu items with consistent padding
    local menu_items=(
        "1) 🚀 Full System (Gazebo + Webcam + Color Detection)"
        "2) 🎮 Gazebo Simulation Only"
        "3) 🧺 Laundry Sorting Assistant"
        "4) 📷 Webcam Color Detection"
        "5) 🦾 Manual Control Mode"
    )

    for item in "${menu_items[@]}"; do
        printf "│ %-*s │\n" $((menu_inner_width)) "$item"
    done

    local fusion_exists=$(check_file "$SENSOR_FUSION_PATH" && echo true || echo false)
    if [ "$fusion_exists" = true ]; then
        printf "│ %-*s │\n" $((menu_inner_width)) "6) 🧠 Sensor Fusion Demo"
        printf "│ %-*s │\n" $((menu_inner_width)) "7) 📁 View Spatial Database"
    fi

    local integration_exists=$(check_file "$INTEGRATION_PATH" && echo true || echo false)
    if [ "$integration_exists" = true ]; then
        printf "│ %-*s │\n" $((menu_inner_width)) "8) 🔗 Unified Integration Mode"
    fi
    
    # Static menu items at the bottom
    printf "│ %-*s │\n" $((menu_inner_width)) "9) 🧹 Kill All ROS Processes"
    printf "│ %-*s │\n" $((menu_inner_width)) "10) 🚪 Exit"

    # Empty line before bottom border
    printf "│%*s│\n" $menu_inner_width ""

    echo "╰"$(printf '─%.0s' $(seq 1 $menu_inner_width))"╯"
    # --- End of Menu Box ---

    read -p "Enter choice [1-10]: " choice
    case $choice in
        1) run_full_system ;;
        2) run_gazebo_only ;;
        3) run_laundry_assistant ;;
        4) run_webcam_color ;;
        5) run_manual_control ;;
        6) [ "$fusion_exists" = true ] && run_sensor_fusion || echo "❌ Invalid choice" ;;
        7) [ "$fusion_exists" = true ] && view_spatial_database || echo "❌ Invalid choice" ;;
        8) [ "$integration_exists" = true ] && run_unified_integration || echo "❌ Invalid choice" ;;
        9) kill_all_processes ;;
        10) echo "👋 Exiting..."; exit 0 ;;
        *) echo "❌ Invalid choice"; exit 1 ;;
    esac
    echo "🏁 CORI system ended."
}

main
